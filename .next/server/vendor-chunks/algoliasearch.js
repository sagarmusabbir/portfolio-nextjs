"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/algoliasearch";
exports.ids = ["vendor-chunks/algoliasearch"];
exports.modules = {

/***/ "(ssr)/./node_modules/algoliasearch/dist/algoliasearch-lite.esm.browser.js":
/*!***************************************************************************!*\
  !*** ./node_modules/algoliasearch/dist/algoliasearch-lite.esm.browser.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction createBrowserLocalStorageCache(options) {\n    const namespaceKey = `algoliasearch-client-js-${options.key}`;\n    // eslint-disable-next-line functional/no-let\n    let storage;\n    const getStorage = ()=>{\n        if (storage === undefined) {\n            storage = options.localStorage || window.localStorage;\n        }\n        return storage;\n    };\n    const getNamespace = ()=>{\n        return JSON.parse(getStorage().getItem(namespaceKey) || \"{}\");\n    };\n    const setNamespace = (namespace)=>{\n        getStorage().setItem(namespaceKey, JSON.stringify(namespace));\n    };\n    const removeOutdatedCacheItems = ()=>{\n        const timeToLive = options.timeToLive ? options.timeToLive * 1000 : null;\n        const namespace = getNamespace();\n        const filteredNamespaceWithoutOldFormattedCacheItems = Object.fromEntries(Object.entries(namespace).filter(([, cacheItem])=>{\n            return cacheItem.timestamp !== undefined;\n        }));\n        setNamespace(filteredNamespaceWithoutOldFormattedCacheItems);\n        if (!timeToLive) return;\n        const filteredNamespaceWithoutExpiredItems = Object.fromEntries(Object.entries(filteredNamespaceWithoutOldFormattedCacheItems).filter(([, cacheItem])=>{\n            const currentTimestamp = new Date().getTime();\n            const isExpired = cacheItem.timestamp + timeToLive < currentTimestamp;\n            return !isExpired;\n        }));\n        setNamespace(filteredNamespaceWithoutExpiredItems);\n    };\n    return {\n        get (key, defaultValue, events = {\n            miss: ()=>Promise.resolve()\n        }) {\n            return Promise.resolve().then(()=>{\n                removeOutdatedCacheItems();\n                const keyAsString = JSON.stringify(key);\n                return getNamespace()[keyAsString];\n            }).then((value)=>{\n                return Promise.all([\n                    value ? value.value : defaultValue(),\n                    value !== undefined\n                ]);\n            }).then(([value, exists])=>{\n                return Promise.all([\n                    value,\n                    exists || events.miss(value)\n                ]);\n            }).then(([value])=>value);\n        },\n        set (key, value) {\n            return Promise.resolve().then(()=>{\n                const namespace = getNamespace();\n                // eslint-disable-next-line functional/immutable-data\n                namespace[JSON.stringify(key)] = {\n                    timestamp: new Date().getTime(),\n                    value\n                };\n                getStorage().setItem(namespaceKey, JSON.stringify(namespace));\n                return value;\n            });\n        },\n        delete (key) {\n            return Promise.resolve().then(()=>{\n                const namespace = getNamespace();\n                // eslint-disable-next-line functional/immutable-data\n                delete namespace[JSON.stringify(key)];\n                getStorage().setItem(namespaceKey, JSON.stringify(namespace));\n            });\n        },\n        clear () {\n            return Promise.resolve().then(()=>{\n                getStorage().removeItem(namespaceKey);\n            });\n        }\n    };\n}\n// @todo Add logger on options to debug when caches go wrong.\nfunction createFallbackableCache(options) {\n    const caches = [\n        ...options.caches\n    ];\n    const current = caches.shift(); // eslint-disable-line functional/immutable-data\n    if (current === undefined) {\n        return createNullCache();\n    }\n    return {\n        get (key, defaultValue, events = {\n            miss: ()=>Promise.resolve()\n        }) {\n            return current.get(key, defaultValue, events).catch(()=>{\n                return createFallbackableCache({\n                    caches\n                }).get(key, defaultValue, events);\n            });\n        },\n        set (key, value) {\n            return current.set(key, value).catch(()=>{\n                return createFallbackableCache({\n                    caches\n                }).set(key, value);\n            });\n        },\n        delete (key) {\n            return current.delete(key).catch(()=>{\n                return createFallbackableCache({\n                    caches\n                }).delete(key);\n            });\n        },\n        clear () {\n            return current.clear().catch(()=>{\n                return createFallbackableCache({\n                    caches\n                }).clear();\n            });\n        }\n    };\n}\nfunction createNullCache() {\n    return {\n        get (_key, defaultValue, events = {\n            miss: ()=>Promise.resolve()\n        }) {\n            const value = defaultValue();\n            return value.then((result)=>Promise.all([\n                    result,\n                    events.miss(result)\n                ])).then(([result])=>result);\n        },\n        set (_key, value) {\n            return Promise.resolve(value);\n        },\n        delete (_key) {\n            return Promise.resolve();\n        },\n        clear () {\n            return Promise.resolve();\n        }\n    };\n}\nfunction createInMemoryCache(options = {\n    serializable: true\n}) {\n    // eslint-disable-next-line functional/no-let\n    let cache = {};\n    return {\n        get (key, defaultValue, events = {\n            miss: ()=>Promise.resolve()\n        }) {\n            const keyAsString = JSON.stringify(key);\n            if (keyAsString in cache) {\n                return Promise.resolve(options.serializable ? JSON.parse(cache[keyAsString]) : cache[keyAsString]);\n            }\n            const promise = defaultValue();\n            const miss = events && events.miss || (()=>Promise.resolve());\n            return promise.then((value)=>miss(value)).then(()=>promise);\n        },\n        set (key, value) {\n            // eslint-disable-next-line functional/immutable-data\n            cache[JSON.stringify(key)] = options.serializable ? JSON.stringify(value) : value;\n            return Promise.resolve(value);\n        },\n        delete (key) {\n            // eslint-disable-next-line functional/immutable-data\n            delete cache[JSON.stringify(key)];\n            return Promise.resolve();\n        },\n        clear () {\n            cache = {};\n            return Promise.resolve();\n        }\n    };\n}\nfunction createAuth(authMode, appId, apiKey) {\n    const credentials = {\n        \"x-algolia-api-key\": apiKey,\n        \"x-algolia-application-id\": appId\n    };\n    return {\n        headers () {\n            return authMode === AuthMode.WithinHeaders ? credentials : {};\n        },\n        queryParameters () {\n            return authMode === AuthMode.WithinQueryParameters ? credentials : {};\n        }\n    };\n}\n// eslint-disable-next-line functional/prefer-readonly-type\nfunction shuffle(array) {\n    let c = array.length - 1; // eslint-disable-line functional/no-let\n    // eslint-disable-next-line functional/no-loop-statement\n    for(c; c > 0; c--){\n        const b = Math.floor(Math.random() * (c + 1));\n        const a = array[c];\n        array[c] = array[b]; // eslint-disable-line functional/immutable-data, no-param-reassign\n        array[b] = a; // eslint-disable-line functional/immutable-data, no-param-reassign\n    }\n    return array;\n}\nfunction addMethods(base, methods) {\n    if (!methods) {\n        return base;\n    }\n    Object.keys(methods).forEach((key)=>{\n        // eslint-disable-next-line functional/immutable-data, no-param-reassign\n        base[key] = methods[key](base);\n    });\n    return base;\n}\nfunction encode(format, ...args) {\n    // eslint-disable-next-line functional/no-let\n    let i = 0;\n    return format.replace(/%s/g, ()=>encodeURIComponent(args[i++]));\n}\nconst version = \"4.20.0\";\nconst AuthMode = {\n    /**\r\n     * If auth credentials should be in query parameters.\r\n     */ WithinQueryParameters: 0,\n    /**\r\n     * If auth credentials should be in headers.\r\n     */ WithinHeaders: 1\n};\nfunction createMappedRequestOptions(requestOptions, timeout) {\n    const options = requestOptions || {};\n    const data = options.data || {};\n    Object.keys(options).forEach((key)=>{\n        if ([\n            \"timeout\",\n            \"headers\",\n            \"queryParameters\",\n            \"data\",\n            \"cacheable\"\n        ].indexOf(key) === -1) {\n            data[key] = options[key]; // eslint-disable-line functional/immutable-data\n        }\n    });\n    return {\n        data: Object.entries(data).length > 0 ? data : undefined,\n        timeout: options.timeout || timeout,\n        headers: options.headers || {},\n        queryParameters: options.queryParameters || {},\n        cacheable: options.cacheable\n    };\n}\nconst CallEnum = {\n    /**\r\n     * If the host is read only.\r\n     */ Read: 1,\n    /**\r\n     * If the host is write only.\r\n     */ Write: 2,\n    /**\r\n     * If the host is both read and write.\r\n     */ Any: 3\n};\nconst HostStatusEnum = {\n    Up: 1,\n    Down: 2,\n    Timeouted: 3\n};\n// By default, API Clients at Algolia have expiration delay\n// of 5 mins. In the JavaScript client, we have 2 mins.\nconst EXPIRATION_DELAY = 2 * 60 * 1000;\nfunction createStatefulHost(host, status = HostStatusEnum.Up) {\n    return {\n        ...host,\n        status,\n        lastUpdate: Date.now()\n    };\n}\nfunction isStatefulHostUp(host) {\n    return host.status === HostStatusEnum.Up || Date.now() - host.lastUpdate > EXPIRATION_DELAY;\n}\nfunction isStatefulHostTimeouted(host) {\n    return host.status === HostStatusEnum.Timeouted && Date.now() - host.lastUpdate <= EXPIRATION_DELAY;\n}\nfunction createStatelessHost(options) {\n    if (typeof options === \"string\") {\n        return {\n            protocol: \"https\",\n            url: options,\n            accept: CallEnum.Any\n        };\n    }\n    return {\n        protocol: options.protocol || \"https\",\n        url: options.url,\n        accept: options.accept || CallEnum.Any\n    };\n}\nconst MethodEnum = {\n    Delete: \"DELETE\",\n    Get: \"GET\",\n    Post: \"POST\",\n    Put: \"PUT\"\n};\nfunction createRetryableOptions(hostsCache, statelessHosts) {\n    return Promise.all(statelessHosts.map((statelessHost)=>{\n        return hostsCache.get(statelessHost, ()=>{\n            return Promise.resolve(createStatefulHost(statelessHost));\n        });\n    })).then((statefulHosts)=>{\n        const hostsUp = statefulHosts.filter((host)=>isStatefulHostUp(host));\n        const hostsTimeouted = statefulHosts.filter((host)=>isStatefulHostTimeouted(host));\n        /**\r\n         * Note, we put the hosts that previously timeouted on the end of the list.\r\n         */ const hostsAvailable = [\n            ...hostsUp,\n            ...hostsTimeouted\n        ];\n        const statelessHostsAvailable = hostsAvailable.length > 0 ? hostsAvailable.map((host)=>createStatelessHost(host)) : statelessHosts;\n        return {\n            getTimeout (timeoutsCount, baseTimeout) {\n                /**\r\n                 * Imagine that you have 4 hosts, if timeouts will increase\r\n                 * on the following way: 1 (timeouted) > 4 (timeouted) > 5 (200)\r\n                 *\r\n                 * Note that, the very next request, we start from the previous timeout\r\n                 *\r\n                 *  5 (timeouted) > 6 (timeouted) > 7 ...\r\n                 *\r\n                 * This strategy may need to be reviewed, but is the strategy on the our\r\n                 * current v3 version.\r\n                 */ const timeoutMultiplier = hostsTimeouted.length === 0 && timeoutsCount === 0 ? 1 : hostsTimeouted.length + 3 + timeoutsCount;\n                return timeoutMultiplier * baseTimeout;\n            },\n            statelessHosts: statelessHostsAvailable\n        };\n    });\n}\nconst isNetworkError = ({ isTimedOut, status })=>{\n    return !isTimedOut && ~~status === 0;\n};\nconst isRetryable = (response)=>{\n    const status = response.status;\n    const isTimedOut = response.isTimedOut;\n    return isTimedOut || isNetworkError(response) || ~~(status / 100) !== 2 && ~~(status / 100) !== 4;\n};\nconst isSuccess = ({ status })=>{\n    return ~~(status / 100) === 2;\n};\nconst retryDecision = (response, outcomes)=>{\n    if (isRetryable(response)) {\n        return outcomes.onRetry(response);\n    }\n    if (isSuccess(response)) {\n        return outcomes.onSuccess(response);\n    }\n    return outcomes.onFail(response);\n};\nfunction retryableRequest(transporter, statelessHosts, request, requestOptions) {\n    const stackTrace = []; // eslint-disable-line functional/prefer-readonly-type\n    /**\r\n     * First we prepare the payload that do not depend from hosts.\r\n     */ const data = serializeData(request, requestOptions);\n    const headers = serializeHeaders(transporter, requestOptions);\n    const method = request.method;\n    // On `GET`, the data is proxied to query parameters.\n    const dataQueryParameters = request.method !== MethodEnum.Get ? {} : {\n        ...request.data,\n        ...requestOptions.data\n    };\n    const queryParameters = {\n        \"x-algolia-agent\": transporter.userAgent.value,\n        ...transporter.queryParameters,\n        ...dataQueryParameters,\n        ...requestOptions.queryParameters\n    };\n    let timeoutsCount = 0; // eslint-disable-line functional/no-let\n    const retry = (hosts, getTimeout)=>{\n        /**\r\n         * We iterate on each host, until there is no host left.\r\n         */ const host = hosts.pop(); // eslint-disable-line functional/immutable-data\n        if (host === undefined) {\n            throw createRetryError(stackTraceWithoutCredentials(stackTrace));\n        }\n        const payload = {\n            data,\n            headers,\n            method,\n            url: serializeUrl(host, request.path, queryParameters),\n            connectTimeout: getTimeout(timeoutsCount, transporter.timeouts.connect),\n            responseTimeout: getTimeout(timeoutsCount, requestOptions.timeout)\n        };\n        /**\r\n         * The stackFrame is pushed to the stackTrace so we\r\n         * can have information about onRetry and onFailure\r\n         * decisions.\r\n         */ const pushToStackTrace = (response)=>{\n            const stackFrame = {\n                request: payload,\n                response,\n                host,\n                triesLeft: hosts.length\n            };\n            // eslint-disable-next-line functional/immutable-data\n            stackTrace.push(stackFrame);\n            return stackFrame;\n        };\n        const decisions = {\n            onSuccess: (response)=>deserializeSuccess(response),\n            onRetry (response) {\n                const stackFrame = pushToStackTrace(response);\n                /**\r\n                 * If response is a timeout, we increaset the number of\r\n                 * timeouts so we can increase the timeout later.\r\n                 */ if (response.isTimedOut) {\n                    timeoutsCount++;\n                }\n                return Promise.all([\n                    /**\r\n                     * Failures are individually send the logger, allowing\r\n                     * the end user to debug / store stack frames even\r\n                     * when a retry error does not happen.\r\n                     */ transporter.logger.info(\"Retryable failure\", stackFrameWithoutCredentials(stackFrame)),\n                    /**\r\n                     * We also store the state of the host in failure cases. If the host, is\r\n                     * down it will remain down for the next 2 minutes. In a timeout situation,\r\n                     * this host will be added end of the list of hosts on the next request.\r\n                     */ transporter.hostsCache.set(host, createStatefulHost(host, response.isTimedOut ? HostStatusEnum.Timeouted : HostStatusEnum.Down))\n                ]).then(()=>retry(hosts, getTimeout));\n            },\n            onFail (response) {\n                pushToStackTrace(response);\n                throw deserializeFailure(response, stackTraceWithoutCredentials(stackTrace));\n            }\n        };\n        return transporter.requester.send(payload).then((response)=>{\n            return retryDecision(response, decisions);\n        });\n    };\n    /**\r\n     * Finally, for each retryable host perform request until we got a non\r\n     * retryable response. Some notes here:\r\n     *\r\n     * 1. The reverse here is applied so we can apply a `pop` later on => more performant.\r\n     * 2. We also get from the retryable options a timeout multiplier that is tailored\r\n     * for the current context.\r\n     */ return createRetryableOptions(transporter.hostsCache, statelessHosts).then((options)=>{\n        return retry([\n            ...options.statelessHosts\n        ].reverse(), options.getTimeout);\n    });\n}\nfunction createTransporter(options) {\n    const { hostsCache, logger, requester, requestsCache, responsesCache, timeouts, userAgent, hosts, queryParameters, headers } = options;\n    const transporter = {\n        hostsCache,\n        logger,\n        requester,\n        requestsCache,\n        responsesCache,\n        timeouts,\n        userAgent,\n        headers,\n        queryParameters,\n        hosts: hosts.map((host)=>createStatelessHost(host)),\n        read (request, requestOptions) {\n            /**\r\n             * First, we compute the user request options. Now, keep in mind,\r\n             * that using request options the user is able to modified the intire\r\n             * payload of the request. Such as headers, query parameters, and others.\r\n             */ const mappedRequestOptions = createMappedRequestOptions(requestOptions, transporter.timeouts.read);\n            const createRetryableRequest = ()=>{\n                /**\r\n                 * Then, we prepare a function factory that contains the construction of\r\n                 * the retryable request. At this point, we may *not* perform the actual\r\n                 * request. But we want to have the function factory ready.\r\n                 */ return retryableRequest(transporter, transporter.hosts.filter((host)=>(host.accept & CallEnum.Read) !== 0), request, mappedRequestOptions);\n            };\n            /**\r\n             * Once we have the function factory ready, we need to determine of the\r\n             * request is \"cacheable\" - should be cached. Note that, once again,\r\n             * the user can force this option.\r\n             */ const cacheable = mappedRequestOptions.cacheable !== undefined ? mappedRequestOptions.cacheable : request.cacheable;\n            /**\r\n             * If is not \"cacheable\", we immediatly trigger the retryable request, no\r\n             * need to check cache implementations.\r\n             */ if (cacheable !== true) {\n                return createRetryableRequest();\n            }\n            /**\r\n             * If the request is \"cacheable\", we need to first compute the key to ask\r\n             * the cache implementations if this request is on progress or if the\r\n             * response already exists on the cache.\r\n             */ const key = {\n                request,\n                mappedRequestOptions,\n                transporter: {\n                    queryParameters: transporter.queryParameters,\n                    headers: transporter.headers\n                }\n            };\n            /**\r\n             * With the computed key, we first ask the responses cache\r\n             * implemention if this request was been resolved before.\r\n             */ return transporter.responsesCache.get(key, ()=>{\n                /**\r\n                 * If the request has never resolved before, we actually ask if there\r\n                 * is a current request with the same key on progress.\r\n                 */ return transporter.requestsCache.get(key, ()=>{\n                    return transporter.requestsCache/**\r\n                         * Finally, if there is no request in progress with the same key,\r\n                         * this `createRetryableRequest()` will actually trigger the\r\n                         * retryable request.\r\n                         */ .set(key, createRetryableRequest()).then((response)=>Promise.all([\n                            transporter.requestsCache.delete(key),\n                            response\n                        ]), (err)=>Promise.all([\n                            transporter.requestsCache.delete(key),\n                            Promise.reject(err)\n                        ])).then(([_, response])=>response);\n                });\n            }, {\n                /**\r\n                 * Of course, once we get this response back from the server, we\r\n                 * tell response cache to actually store the received response\r\n                 * to be used later.\r\n                 */ miss: (response)=>transporter.responsesCache.set(key, response)\n            });\n        },\n        write (request, requestOptions) {\n            /**\r\n             * On write requests, no cache mechanisms are applied, and we\r\n             * proxy the request immediately to the requester.\r\n             */ return retryableRequest(transporter, transporter.hosts.filter((host)=>(host.accept & CallEnum.Write) !== 0), request, createMappedRequestOptions(requestOptions, transporter.timeouts.write));\n        }\n    };\n    return transporter;\n}\nfunction createUserAgent(version) {\n    const userAgent = {\n        value: `Algolia for JavaScript (${version})`,\n        add (options) {\n            const addedUserAgent = `; ${options.segment}${options.version !== undefined ? ` (${options.version})` : \"\"}`;\n            if (userAgent.value.indexOf(addedUserAgent) === -1) {\n                // eslint-disable-next-line functional/immutable-data\n                userAgent.value = `${userAgent.value}${addedUserAgent}`;\n            }\n            return userAgent;\n        }\n    };\n    return userAgent;\n}\nfunction deserializeSuccess(response) {\n    // eslint-disable-next-line functional/no-try-statement\n    try {\n        return JSON.parse(response.content);\n    } catch (e) {\n        throw createDeserializationError(e.message, response);\n    }\n}\nfunction deserializeFailure({ content, status }, stackFrame) {\n    // eslint-disable-next-line functional/no-let\n    let message = content;\n    // eslint-disable-next-line functional/no-try-statement\n    try {\n        message = JSON.parse(content).message;\n    } catch (e) {\n    // ..\n    }\n    return createApiError(message, status, stackFrame);\n}\nfunction serializeUrl(host, path, queryParameters) {\n    const queryParametersAsString = serializeQueryParameters(queryParameters);\n    // eslint-disable-next-line functional/no-let\n    let url = `${host.protocol}://${host.url}/${path.charAt(0) === \"/\" ? path.substr(1) : path}`;\n    if (queryParametersAsString.length) {\n        url += `?${queryParametersAsString}`;\n    }\n    return url;\n}\nfunction serializeQueryParameters(parameters) {\n    const isObjectOrArray = (value)=>Object.prototype.toString.call(value) === \"[object Object]\" || Object.prototype.toString.call(value) === \"[object Array]\";\n    return Object.keys(parameters).map((key)=>encode(\"%s=%s\", key, isObjectOrArray(parameters[key]) ? JSON.stringify(parameters[key]) : parameters[key])).join(\"&\");\n}\nfunction serializeData(request, requestOptions) {\n    if (request.method === MethodEnum.Get || request.data === undefined && requestOptions.data === undefined) {\n        return undefined;\n    }\n    const data = Array.isArray(request.data) ? request.data : {\n        ...request.data,\n        ...requestOptions.data\n    };\n    return JSON.stringify(data);\n}\nfunction serializeHeaders(transporter, requestOptions) {\n    const headers = {\n        ...transporter.headers,\n        ...requestOptions.headers\n    };\n    const serializedHeaders = {};\n    Object.keys(headers).forEach((header)=>{\n        const value = headers[header];\n        // @ts-ignore\n        // eslint-disable-next-line functional/immutable-data\n        serializedHeaders[header.toLowerCase()] = value;\n    });\n    return serializedHeaders;\n}\nfunction stackTraceWithoutCredentials(stackTrace) {\n    return stackTrace.map((stackFrame)=>stackFrameWithoutCredentials(stackFrame));\n}\nfunction stackFrameWithoutCredentials(stackFrame) {\n    const modifiedHeaders = stackFrame.request.headers[\"x-algolia-api-key\"] ? {\n        \"x-algolia-api-key\": \"*****\"\n    } : {};\n    return {\n        ...stackFrame,\n        request: {\n            ...stackFrame.request,\n            headers: {\n                ...stackFrame.request.headers,\n                ...modifiedHeaders\n            }\n        }\n    };\n}\nfunction createApiError(message, status, transporterStackTrace) {\n    return {\n        name: \"ApiError\",\n        message,\n        status,\n        transporterStackTrace\n    };\n}\nfunction createDeserializationError(message, response) {\n    return {\n        name: \"DeserializationError\",\n        message,\n        response\n    };\n}\nfunction createRetryError(transporterStackTrace) {\n    return {\n        name: \"RetryError\",\n        message: \"Unreachable hosts - your application id may be incorrect. If the error persists, contact support@algolia.com.\",\n        transporterStackTrace\n    };\n}\nconst createSearchClient = (options)=>{\n    const appId = options.appId;\n    const auth = createAuth(options.authMode !== undefined ? options.authMode : AuthMode.WithinHeaders, appId, options.apiKey);\n    const transporter = createTransporter({\n        hosts: [\n            {\n                url: `${appId}-dsn.algolia.net`,\n                accept: CallEnum.Read\n            },\n            {\n                url: `${appId}.algolia.net`,\n                accept: CallEnum.Write\n            }\n        ].concat(shuffle([\n            {\n                url: `${appId}-1.algolianet.com`\n            },\n            {\n                url: `${appId}-2.algolianet.com`\n            },\n            {\n                url: `${appId}-3.algolianet.com`\n            }\n        ])),\n        ...options,\n        headers: {\n            ...auth.headers(),\n            ...{\n                \"content-type\": \"application/x-www-form-urlencoded\"\n            },\n            ...options.headers\n        },\n        queryParameters: {\n            ...auth.queryParameters(),\n            ...options.queryParameters\n        }\n    });\n    const base = {\n        transporter,\n        appId,\n        addAlgoliaAgent (segment, version) {\n            transporter.userAgent.add({\n                segment,\n                version\n            });\n        },\n        clearCache () {\n            return Promise.all([\n                transporter.requestsCache.clear(),\n                transporter.responsesCache.clear()\n            ]).then(()=>undefined);\n        }\n    };\n    return addMethods(base, options.methods);\n};\nconst customRequest = (base)=>{\n    return (request, requestOptions)=>{\n        if (request.method === MethodEnum.Get) {\n            return base.transporter.read(request, requestOptions);\n        }\n        return base.transporter.write(request, requestOptions);\n    };\n};\nconst initIndex = (base)=>{\n    return (indexName, options = {})=>{\n        const searchIndex = {\n            transporter: base.transporter,\n            appId: base.appId,\n            indexName\n        };\n        return addMethods(searchIndex, options.methods);\n    };\n};\nconst multipleQueries = (base)=>{\n    return (queries, requestOptions)=>{\n        const requests = queries.map((query)=>{\n            return {\n                ...query,\n                params: serializeQueryParameters(query.params || {})\n            };\n        });\n        return base.transporter.read({\n            method: MethodEnum.Post,\n            path: \"1/indexes/*/queries\",\n            data: {\n                requests\n            },\n            cacheable: true\n        }, requestOptions);\n    };\n};\nconst multipleSearchForFacetValues = (base)=>{\n    return (queries, requestOptions)=>{\n        return Promise.all(queries.map((query)=>{\n            const { facetName, facetQuery, ...params } = query.params;\n            return initIndex(base)(query.indexName, {\n                methods: {\n                    searchForFacetValues\n                }\n            }).searchForFacetValues(facetName, facetQuery, {\n                ...requestOptions,\n                ...params\n            });\n        }));\n    };\n};\nconst findAnswers = (base)=>{\n    return (query, queryLanguages, requestOptions)=>{\n        return base.transporter.read({\n            method: MethodEnum.Post,\n            path: encode(\"1/answers/%s/prediction\", base.indexName),\n            data: {\n                query,\n                queryLanguages\n            },\n            cacheable: true\n        }, requestOptions);\n    };\n};\nconst search = (base)=>{\n    return (query, requestOptions)=>{\n        return base.transporter.read({\n            method: MethodEnum.Post,\n            path: encode(\"1/indexes/%s/query\", base.indexName),\n            data: {\n                query\n            },\n            cacheable: true\n        }, requestOptions);\n    };\n};\nconst searchForFacetValues = (base)=>{\n    return (facetName, facetQuery, requestOptions)=>{\n        return base.transporter.read({\n            method: MethodEnum.Post,\n            path: encode(\"1/indexes/%s/facets/%s/query\", base.indexName, facetName),\n            data: {\n                facetQuery\n            },\n            cacheable: true\n        }, requestOptions);\n    };\n};\nconst LogLevelEnum = {\n    Debug: 1,\n    Info: 2,\n    Error: 3\n};\n/* eslint no-console: 0 */ function createConsoleLogger(logLevel) {\n    return {\n        debug (message, args) {\n            if (LogLevelEnum.Debug >= logLevel) {\n                console.debug(message, args);\n            }\n            return Promise.resolve();\n        },\n        info (message, args) {\n            if (LogLevelEnum.Info >= logLevel) {\n                console.info(message, args);\n            }\n            return Promise.resolve();\n        },\n        error (message, args) {\n            console.error(message, args);\n            return Promise.resolve();\n        }\n    };\n}\nfunction createBrowserXhrRequester() {\n    return {\n        send (request) {\n            return new Promise((resolve)=>{\n                const baseRequester = new XMLHttpRequest();\n                baseRequester.open(request.method, request.url, true);\n                Object.keys(request.headers).forEach((key)=>baseRequester.setRequestHeader(key, request.headers[key]));\n                const createTimeout = (timeout, content)=>{\n                    return setTimeout(()=>{\n                        baseRequester.abort();\n                        resolve({\n                            status: 0,\n                            content,\n                            isTimedOut: true\n                        });\n                    }, timeout * 1000);\n                };\n                const connectTimeout = createTimeout(request.connectTimeout, \"Connection timeout\");\n                // eslint-disable-next-line functional/no-let\n                let responseTimeout;\n                // eslint-disable-next-line functional/immutable-data\n                baseRequester.onreadystatechange = ()=>{\n                    if (baseRequester.readyState > baseRequester.OPENED && responseTimeout === undefined) {\n                        clearTimeout(connectTimeout);\n                        responseTimeout = createTimeout(request.responseTimeout, \"Socket timeout\");\n                    }\n                };\n                // eslint-disable-next-line functional/immutable-data\n                baseRequester.onerror = ()=>{\n                    // istanbul ignore next\n                    if (baseRequester.status === 0) {\n                        clearTimeout(connectTimeout);\n                        clearTimeout(responseTimeout);\n                        resolve({\n                            content: baseRequester.responseText || \"Network request failed\",\n                            status: baseRequester.status,\n                            isTimedOut: false\n                        });\n                    }\n                };\n                //  eslint-disable-next-line functional/immutable-data\n                baseRequester.onload = ()=>{\n                    clearTimeout(connectTimeout);\n                    clearTimeout(responseTimeout);\n                    resolve({\n                        content: baseRequester.responseText,\n                        status: baseRequester.status,\n                        isTimedOut: false\n                    });\n                };\n                baseRequester.send(request.data);\n            });\n        }\n    };\n}\nfunction algoliasearch(appId, apiKey, options) {\n    const commonOptions = {\n        appId,\n        apiKey,\n        timeouts: {\n            connect: 1,\n            read: 2,\n            write: 30\n        },\n        requester: createBrowserXhrRequester(),\n        logger: createConsoleLogger(LogLevelEnum.Error),\n        responsesCache: createInMemoryCache(),\n        requestsCache: createInMemoryCache({\n            serializable: false\n        }),\n        hostsCache: createFallbackableCache({\n            caches: [\n                createBrowserLocalStorageCache({\n                    key: `${version}-${appId}`\n                }),\n                createInMemoryCache()\n            ]\n        }),\n        userAgent: createUserAgent(version).add({\n            segment: \"Browser\",\n            version: \"lite\"\n        }),\n        authMode: AuthMode.WithinQueryParameters\n    };\n    return createSearchClient({\n        ...commonOptions,\n        ...options,\n        methods: {\n            search: multipleQueries,\n            searchForFacetValues: multipleSearchForFacetValues,\n            multipleQueries,\n            multipleSearchForFacetValues,\n            customRequest,\n            initIndex: (base)=>(indexName)=>{\n                    return initIndex(base)(indexName, {\n                        methods: {\n                            search,\n                            searchForFacetValues,\n                            findAnswers\n                        }\n                    });\n                }\n        }\n    });\n}\n// eslint-disable-next-line functional/immutable-data\nalgoliasearch.version = version;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (algoliasearch);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWxnb2xpYXNlYXJjaC9kaXN0L2FsZ29saWFzZWFyY2gtbGl0ZS5lc20uYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsU0FBU0EsK0JBQStCQyxPQUFPO0lBQzNDLE1BQU1DLGVBQWUsQ0FBQyx3QkFBd0IsRUFBRUQsUUFBUUUsR0FBRyxDQUFDLENBQUM7SUFDN0QsNkNBQTZDO0lBQzdDLElBQUlDO0lBQ0osTUFBTUMsYUFBYTtRQUNmLElBQUlELFlBQVlFLFdBQVc7WUFDdkJGLFVBQVVILFFBQVFNLFlBQVksSUFBSUMsT0FBT0QsWUFBWTtRQUN6RDtRQUNBLE9BQU9IO0lBQ1g7SUFDQSxNQUFNSyxlQUFlO1FBQ2pCLE9BQU9DLEtBQUtDLEtBQUssQ0FBQ04sYUFBYU8sT0FBTyxDQUFDVixpQkFBaUI7SUFDNUQ7SUFDQSxNQUFNVyxlQUFlLENBQUNDO1FBQ2xCVCxhQUFhVSxPQUFPLENBQUNiLGNBQWNRLEtBQUtNLFNBQVMsQ0FBQ0Y7SUFDdEQ7SUFDQSxNQUFNRywyQkFBMkI7UUFDN0IsTUFBTUMsYUFBYWpCLFFBQVFpQixVQUFVLEdBQUdqQixRQUFRaUIsVUFBVSxHQUFHLE9BQU87UUFDcEUsTUFBTUosWUFBWUw7UUFDbEIsTUFBTVUsaURBQWlEQyxPQUFPQyxXQUFXLENBQUNELE9BQU9FLE9BQU8sQ0FBQ1IsV0FBV1MsTUFBTSxDQUFDLENBQUMsR0FBR0MsVUFBVTtZQUNySCxPQUFPQSxVQUFVQyxTQUFTLEtBQUtuQjtRQUNuQztRQUNBTyxhQUFhTTtRQUNiLElBQUksQ0FBQ0QsWUFDRDtRQUNKLE1BQU1RLHVDQUF1Q04sT0FBT0MsV0FBVyxDQUFDRCxPQUFPRSxPQUFPLENBQUNILGdEQUFnREksTUFBTSxDQUFDLENBQUMsR0FBR0MsVUFBVTtZQUNoSixNQUFNRyxtQkFBbUIsSUFBSUMsT0FBT0MsT0FBTztZQUMzQyxNQUFNQyxZQUFZTixVQUFVQyxTQUFTLEdBQUdQLGFBQWFTO1lBQ3JELE9BQU8sQ0FBQ0c7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YUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RhaWx3aW5kLW5leHRqcy1zdGFydGVyLWJsb2cvLi9ub2RlX21vZHVsZXMvYWxnb2xpYXNlYXJjaC9kaXN0L2FsZ29saWFzZWFyY2gtbGl0ZS5lc20uYnJvd3Nlci5qcz8yY2U4Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJMb2NhbFN0b3JhZ2VDYWNoZShvcHRpb25zKSB7XHJcbiAgICBjb25zdCBuYW1lc3BhY2VLZXkgPSBgYWxnb2xpYXNlYXJjaC1jbGllbnQtanMtJHtvcHRpb25zLmtleX1gO1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmN0aW9uYWwvbm8tbGV0XHJcbiAgICBsZXQgc3RvcmFnZTtcclxuICAgIGNvbnN0IGdldFN0b3JhZ2UgPSAoKSA9PiB7XHJcbiAgICAgICAgaWYgKHN0b3JhZ2UgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBzdG9yYWdlID0gb3B0aW9ucy5sb2NhbFN0b3JhZ2UgfHwgd2luZG93LmxvY2FsU3RvcmFnZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0b3JhZ2U7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgZ2V0TmFtZXNwYWNlID0gKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGdldFN0b3JhZ2UoKS5nZXRJdGVtKG5hbWVzcGFjZUtleSkgfHwgJ3t9Jyk7XHJcbiAgICB9O1xyXG4gICAgY29uc3Qgc2V0TmFtZXNwYWNlID0gKG5hbWVzcGFjZSkgPT4ge1xyXG4gICAgICAgIGdldFN0b3JhZ2UoKS5zZXRJdGVtKG5hbWVzcGFjZUtleSwgSlNPTi5zdHJpbmdpZnkobmFtZXNwYWNlKSk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcmVtb3ZlT3V0ZGF0ZWRDYWNoZUl0ZW1zID0gKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHRpbWVUb0xpdmUgPSBvcHRpb25zLnRpbWVUb0xpdmUgPyBvcHRpb25zLnRpbWVUb0xpdmUgKiAxMDAwIDogbnVsbDtcclxuICAgICAgICBjb25zdCBuYW1lc3BhY2UgPSBnZXROYW1lc3BhY2UoKTtcclxuICAgICAgICBjb25zdCBmaWx0ZXJlZE5hbWVzcGFjZVdpdGhvdXRPbGRGb3JtYXR0ZWRDYWNoZUl0ZW1zID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKG5hbWVzcGFjZSkuZmlsdGVyKChbLCBjYWNoZUl0ZW1dKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWNoZUl0ZW0udGltZXN0YW1wICE9PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHNldE5hbWVzcGFjZShmaWx0ZXJlZE5hbWVzcGFjZVdpdGhvdXRPbGRGb3JtYXR0ZWRDYWNoZUl0ZW1zKTtcclxuICAgICAgICBpZiAoIXRpbWVUb0xpdmUpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBjb25zdCBmaWx0ZXJlZE5hbWVzcGFjZVdpdGhvdXRFeHBpcmVkSXRlbXMgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoZmlsdGVyZWROYW1lc3BhY2VXaXRob3V0T2xkRm9ybWF0dGVkQ2FjaGVJdGVtcykuZmlsdGVyKChbLCBjYWNoZUl0ZW1dKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lc3RhbXAgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgICAgICAgY29uc3QgaXNFeHBpcmVkID0gY2FjaGVJdGVtLnRpbWVzdGFtcCArIHRpbWVUb0xpdmUgPCBjdXJyZW50VGltZXN0YW1wO1xyXG4gICAgICAgICAgICByZXR1cm4gIWlzRXhwaXJlZDtcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgc2V0TmFtZXNwYWNlKGZpbHRlcmVkTmFtZXNwYWNlV2l0aG91dEV4cGlyZWRJdGVtcyk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBnZXQoa2V5LCBkZWZhdWx0VmFsdWUsIGV2ZW50cyA9IHtcclxuICAgICAgICAgICAgbWlzczogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCksXHJcbiAgICAgICAgfSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcclxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZU91dGRhdGVkQ2FjaGVJdGVtcygpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5QXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShrZXkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldE5hbWVzcGFjZSgpW2tleUFzU3RyaW5nXTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC50aGVuKHZhbHVlID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbdmFsdWUgPyB2YWx1ZS52YWx1ZSA6IGRlZmF1bHRWYWx1ZSgpLCB2YWx1ZSAhPT0gdW5kZWZpbmVkXSk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAudGhlbigoW3ZhbHVlLCBleGlzdHNdKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW3ZhbHVlLCBleGlzdHMgfHwgZXZlbnRzLm1pc3ModmFsdWUpXSk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAudGhlbigoW3ZhbHVlXSkgPT4gdmFsdWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0KGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZXNwYWNlID0gZ2V0TmFtZXNwYWNlKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9pbW11dGFibGUtZGF0YVxyXG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlW0pTT04uc3RyaW5naWZ5KGtleSldID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS5nZXRUaW1lKCksXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgZ2V0U3RvcmFnZSgpLnNldEl0ZW0obmFtZXNwYWNlS2V5LCBKU09OLnN0cmluZ2lmeShuYW1lc3BhY2UpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZWxldGUoa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWVzcGFjZSA9IGdldE5hbWVzcGFjZSgpO1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmN0aW9uYWwvaW1tdXRhYmxlLWRhdGFcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBuYW1lc3BhY2VbSlNPTi5zdHJpbmdpZnkoa2V5KV07XHJcbiAgICAgICAgICAgICAgICBnZXRTdG9yYWdlKCkuc2V0SXRlbShuYW1lc3BhY2VLZXksIEpTT04uc3RyaW5naWZ5KG5hbWVzcGFjZSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNsZWFyKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBnZXRTdG9yYWdlKCkucmVtb3ZlSXRlbShuYW1lc3BhY2VLZXkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxuXG4vLyBAdG9kbyBBZGQgbG9nZ2VyIG9uIG9wdGlvbnMgdG8gZGVidWcgd2hlbiBjYWNoZXMgZ28gd3JvbmcuXHJcbmZ1bmN0aW9uIGNyZWF0ZUZhbGxiYWNrYWJsZUNhY2hlKG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IGNhY2hlcyA9IFsuLi5vcHRpb25zLmNhY2hlc107XHJcbiAgICBjb25zdCBjdXJyZW50ID0gY2FjaGVzLnNoaWZ0KCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZnVuY3Rpb25hbC9pbW11dGFibGUtZGF0YVxyXG4gICAgaWYgKGN1cnJlbnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVOdWxsQ2FjaGUoKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZ2V0KGtleSwgZGVmYXVsdFZhbHVlLCBldmVudHMgPSB7XHJcbiAgICAgICAgICAgIG1pc3M6ICgpID0+IFByb21pc2UucmVzb2x2ZSgpLFxyXG4gICAgICAgIH0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQuZ2V0KGtleSwgZGVmYXVsdFZhbHVlLCBldmVudHMpLmNhdGNoKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVGYWxsYmFja2FibGVDYWNoZSh7IGNhY2hlcyB9KS5nZXQoa2V5LCBkZWZhdWx0VmFsdWUsIGV2ZW50cyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0KGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQuc2V0KGtleSwgdmFsdWUpLmNhdGNoKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVGYWxsYmFja2FibGVDYWNoZSh7IGNhY2hlcyB9KS5zZXQoa2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVsZXRlKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY3VycmVudC5kZWxldGUoa2V5KS5jYXRjaCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlRmFsbGJhY2thYmxlQ2FjaGUoeyBjYWNoZXMgfSkuZGVsZXRlKGtleSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2xlYXIoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50LmNsZWFyKCkuY2F0Y2goKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUZhbGxiYWNrYWJsZUNhY2hlKHsgY2FjaGVzIH0pLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU51bGxDYWNoZSgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZ2V0KF9rZXksIGRlZmF1bHRWYWx1ZSwgZXZlbnRzID0ge1xyXG4gICAgICAgICAgICBtaXNzOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoKSxcclxuICAgICAgICB9KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZGVmYXVsdFZhbHVlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgLnRoZW4ocmVzdWx0ID0+IFByb21pc2UuYWxsKFtyZXN1bHQsIGV2ZW50cy5taXNzKHJlc3VsdCldKSlcclxuICAgICAgICAgICAgICAgIC50aGVuKChbcmVzdWx0XSkgPT4gcmVzdWx0KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldChfa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlbGV0ZShfa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNsZWFyKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW5NZW1vcnlDYWNoZShvcHRpb25zID0geyBzZXJpYWxpemFibGU6IHRydWUgfSkge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmN0aW9uYWwvbm8tbGV0XHJcbiAgICBsZXQgY2FjaGUgPSB7fTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZ2V0KGtleSwgZGVmYXVsdFZhbHVlLCBldmVudHMgPSB7XHJcbiAgICAgICAgICAgIG1pc3M6ICgpID0+IFByb21pc2UucmVzb2x2ZSgpLFxyXG4gICAgICAgIH0pIHtcclxuICAgICAgICAgICAgY29uc3Qga2V5QXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShrZXkpO1xyXG4gICAgICAgICAgICBpZiAoa2V5QXNTdHJpbmcgaW4gY2FjaGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUob3B0aW9ucy5zZXJpYWxpemFibGUgPyBKU09OLnBhcnNlKGNhY2hlW2tleUFzU3RyaW5nXSkgOiBjYWNoZVtrZXlBc1N0cmluZ10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBkZWZhdWx0VmFsdWUoKTtcclxuICAgICAgICAgICAgY29uc3QgbWlzcyA9IChldmVudHMgJiYgZXZlbnRzLm1pc3MpIHx8ICgoKSA9PiBQcm9taXNlLnJlc29sdmUoKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oKHZhbHVlKSA9PiBtaXNzKHZhbHVlKSkudGhlbigoKSA9PiBwcm9taXNlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jdGlvbmFsL2ltbXV0YWJsZS1kYXRhXHJcbiAgICAgICAgICAgIGNhY2hlW0pTT04uc3RyaW5naWZ5KGtleSldID0gb3B0aW9ucy5zZXJpYWxpemFibGUgPyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgOiB2YWx1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZWxldGUoa2V5KSB7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jdGlvbmFsL2ltbXV0YWJsZS1kYXRhXHJcbiAgICAgICAgICAgIGRlbGV0ZSBjYWNoZVtKU09OLnN0cmluZ2lmeShrZXkpXTtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2xlYXIoKSB7XHJcbiAgICAgICAgICAgIGNhY2hlID0ge307XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxuXG5mdW5jdGlvbiBjcmVhdGVBdXRoKGF1dGhNb2RlLCBhcHBJZCwgYXBpS2V5KSB7XHJcbiAgICBjb25zdCBjcmVkZW50aWFscyA9IHtcclxuICAgICAgICAneC1hbGdvbGlhLWFwaS1rZXknOiBhcGlLZXksXHJcbiAgICAgICAgJ3gtYWxnb2xpYS1hcHBsaWNhdGlvbi1pZCc6IGFwcElkLFxyXG4gICAgfTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaGVhZGVycygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGF1dGhNb2RlID09PSBBdXRoTW9kZS5XaXRoaW5IZWFkZXJzID8gY3JlZGVudGlhbHMgOiB7fTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHF1ZXJ5UGFyYW1ldGVycygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGF1dGhNb2RlID09PSBBdXRoTW9kZS5XaXRoaW5RdWVyeVBhcmFtZXRlcnMgPyBjcmVkZW50aWFscyA6IHt9O1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jdGlvbmFsL3ByZWZlci1yZWFkb25seS10eXBlXHJcbmZ1bmN0aW9uIHNodWZmbGUoYXJyYXkpIHtcclxuICAgIGxldCBjID0gYXJyYXkubGVuZ3RoIC0gMTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmdW5jdGlvbmFsL25vLWxldFxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmN0aW9uYWwvbm8tbG9vcC1zdGF0ZW1lbnRcclxuICAgIGZvciAoYzsgYyA+IDA7IGMtLSkge1xyXG4gICAgICAgIGNvbnN0IGIgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoYyArIDEpKTtcclxuICAgICAgICBjb25zdCBhID0gYXJyYXlbY107XHJcbiAgICAgICAgYXJyYXlbY10gPSBhcnJheVtiXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmdW5jdGlvbmFsL2ltbXV0YWJsZS1kYXRhLCBuby1wYXJhbS1yZWFzc2lnblxyXG4gICAgICAgIGFycmF5W2JdID0gYTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmdW5jdGlvbmFsL2ltbXV0YWJsZS1kYXRhLCBuby1wYXJhbS1yZWFzc2lnblxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFycmF5O1xyXG59XHJcbmZ1bmN0aW9uIGFkZE1ldGhvZHMoYmFzZSwgbWV0aG9kcykge1xyXG4gICAgaWYgKCFtZXRob2RzKSB7XHJcbiAgICAgICAgcmV0dXJuIGJhc2U7XHJcbiAgICB9XHJcbiAgICBPYmplY3Qua2V5cyhtZXRob2RzKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmN0aW9uYWwvaW1tdXRhYmxlLWRhdGEsIG5vLXBhcmFtLXJlYXNzaWduXHJcbiAgICAgICAgYmFzZVtrZXldID0gbWV0aG9kc1trZXldKGJhc2UpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gYmFzZTtcclxufVxyXG5mdW5jdGlvbiBlbmNvZGUoZm9ybWF0LCAuLi5hcmdzKSB7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9uby1sZXRcclxuICAgIGxldCBpID0gMDtcclxuICAgIHJldHVybiBmb3JtYXQucmVwbGFjZSgvJXMvZywgKCkgPT4gZW5jb2RlVVJJQ29tcG9uZW50KGFyZ3NbaSsrXSkpO1xyXG59XG5cbmNvbnN0IHZlcnNpb24gPSAnNC4yMC4wJztcblxuY29uc3QgQXV0aE1vZGUgPSB7XHJcbiAgICAvKipcclxuICAgICAqIElmIGF1dGggY3JlZGVudGlhbHMgc2hvdWxkIGJlIGluIHF1ZXJ5IHBhcmFtZXRlcnMuXHJcbiAgICAgKi9cclxuICAgIFdpdGhpblF1ZXJ5UGFyYW1ldGVyczogMCxcclxuICAgIC8qKlxyXG4gICAgICogSWYgYXV0aCBjcmVkZW50aWFscyBzaG91bGQgYmUgaW4gaGVhZGVycy5cclxuICAgICAqL1xyXG4gICAgV2l0aGluSGVhZGVyczogMSxcclxufTtcblxuZnVuY3Rpb24gY3JlYXRlTWFwcGVkUmVxdWVzdE9wdGlvbnMocmVxdWVzdE9wdGlvbnMsIHRpbWVvdXQpIHtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSByZXF1ZXN0T3B0aW9ucyB8fCB7fTtcclxuICAgIGNvbnN0IGRhdGEgPSBvcHRpb25zLmRhdGEgfHwge307XHJcbiAgICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgaWYgKFsndGltZW91dCcsICdoZWFkZXJzJywgJ3F1ZXJ5UGFyYW1ldGVycycsICdkYXRhJywgJ2NhY2hlYWJsZSddLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgZGF0YVtrZXldID0gb3B0aW9uc1trZXldOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmN0aW9uYWwvaW1tdXRhYmxlLWRhdGFcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZGF0YTogT2JqZWN0LmVudHJpZXMoZGF0YSkubGVuZ3RoID4gMCA/IGRhdGEgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgdGltZW91dDogb3B0aW9ucy50aW1lb3V0IHx8IHRpbWVvdXQsXHJcbiAgICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzIHx8IHt9LFxyXG4gICAgICAgIHF1ZXJ5UGFyYW1ldGVyczogb3B0aW9ucy5xdWVyeVBhcmFtZXRlcnMgfHwge30sXHJcbiAgICAgICAgY2FjaGVhYmxlOiBvcHRpb25zLmNhY2hlYWJsZSxcclxuICAgIH07XHJcbn1cblxuY29uc3QgQ2FsbEVudW0gPSB7XHJcbiAgICAvKipcclxuICAgICAqIElmIHRoZSBob3N0IGlzIHJlYWQgb25seS5cclxuICAgICAqL1xyXG4gICAgUmVhZDogMSxcclxuICAgIC8qKlxyXG4gICAgICogSWYgdGhlIGhvc3QgaXMgd3JpdGUgb25seS5cclxuICAgICAqL1xyXG4gICAgV3JpdGU6IDIsXHJcbiAgICAvKipcclxuICAgICAqIElmIHRoZSBob3N0IGlzIGJvdGggcmVhZCBhbmQgd3JpdGUuXHJcbiAgICAgKi9cclxuICAgIEFueTogMyxcclxufTtcblxuY29uc3QgSG9zdFN0YXR1c0VudW0gPSB7XHJcbiAgICBVcDogMSxcclxuICAgIERvd246IDIsXHJcbiAgICBUaW1lb3V0ZWQ6IDMsXHJcbn07XG5cbi8vIEJ5IGRlZmF1bHQsIEFQSSBDbGllbnRzIGF0IEFsZ29saWEgaGF2ZSBleHBpcmF0aW9uIGRlbGF5XHJcbi8vIG9mIDUgbWlucy4gSW4gdGhlIEphdmFTY3JpcHQgY2xpZW50LCB3ZSBoYXZlIDIgbWlucy5cclxuY29uc3QgRVhQSVJBVElPTl9ERUxBWSA9IDIgKiA2MCAqIDEwMDA7XHJcbmZ1bmN0aW9uIGNyZWF0ZVN0YXRlZnVsSG9zdChob3N0LCBzdGF0dXMgPSBIb3N0U3RhdHVzRW51bS5VcCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAuLi5ob3N0LFxyXG4gICAgICAgIHN0YXR1cyxcclxuICAgICAgICBsYXN0VXBkYXRlOiBEYXRlLm5vdygpLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBpc1N0YXRlZnVsSG9zdFVwKGhvc3QpIHtcclxuICAgIHJldHVybiBob3N0LnN0YXR1cyA9PT0gSG9zdFN0YXR1c0VudW0uVXAgfHwgRGF0ZS5ub3coKSAtIGhvc3QubGFzdFVwZGF0ZSA+IEVYUElSQVRJT05fREVMQVk7XHJcbn1cclxuZnVuY3Rpb24gaXNTdGF0ZWZ1bEhvc3RUaW1lb3V0ZWQoaG9zdCkge1xyXG4gICAgcmV0dXJuIChob3N0LnN0YXR1cyA9PT0gSG9zdFN0YXR1c0VudW0uVGltZW91dGVkICYmIERhdGUubm93KCkgLSBob3N0Lmxhc3RVcGRhdGUgPD0gRVhQSVJBVElPTl9ERUxBWSk7XHJcbn1cblxuZnVuY3Rpb24gY3JlYXRlU3RhdGVsZXNzSG9zdChvcHRpb25zKSB7XHJcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcHJvdG9jb2w6ICdodHRwcycsXHJcbiAgICAgICAgICAgIHVybDogb3B0aW9ucyxcclxuICAgICAgICAgICAgYWNjZXB0OiBDYWxsRW51bS5BbnksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcHJvdG9jb2w6IG9wdGlvbnMucHJvdG9jb2wgfHwgJ2h0dHBzJyxcclxuICAgICAgICB1cmw6IG9wdGlvbnMudXJsLFxyXG4gICAgICAgIGFjY2VwdDogb3B0aW9ucy5hY2NlcHQgfHwgQ2FsbEVudW0uQW55LFxyXG4gICAgfTtcclxufVxuXG5jb25zdCBNZXRob2RFbnVtID0ge1xyXG4gICAgRGVsZXRlOiAnREVMRVRFJyxcclxuICAgIEdldDogJ0dFVCcsXHJcbiAgICBQb3N0OiAnUE9TVCcsXHJcbiAgICBQdXQ6ICdQVVQnLFxyXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVSZXRyeWFibGVPcHRpb25zKGhvc3RzQ2FjaGUsIHN0YXRlbGVzc0hvc3RzKSB7XHJcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoc3RhdGVsZXNzSG9zdHMubWFwKHN0YXRlbGVzc0hvc3QgPT4ge1xyXG4gICAgICAgIHJldHVybiBob3N0c0NhY2hlLmdldChzdGF0ZWxlc3NIb3N0LCAoKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY3JlYXRlU3RhdGVmdWxIb3N0KHN0YXRlbGVzc0hvc3QpKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pKS50aGVuKHN0YXRlZnVsSG9zdHMgPT4ge1xyXG4gICAgICAgIGNvbnN0IGhvc3RzVXAgPSBzdGF0ZWZ1bEhvc3RzLmZpbHRlcihob3N0ID0+IGlzU3RhdGVmdWxIb3N0VXAoaG9zdCkpO1xyXG4gICAgICAgIGNvbnN0IGhvc3RzVGltZW91dGVkID0gc3RhdGVmdWxIb3N0cy5maWx0ZXIoaG9zdCA9PiBpc1N0YXRlZnVsSG9zdFRpbWVvdXRlZChob3N0KSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTm90ZSwgd2UgcHV0IHRoZSBob3N0cyB0aGF0IHByZXZpb3VzbHkgdGltZW91dGVkIG9uIHRoZSBlbmQgb2YgdGhlIGxpc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29uc3QgaG9zdHNBdmFpbGFibGUgPSBbLi4uaG9zdHNVcCwgLi4uaG9zdHNUaW1lb3V0ZWRdO1xyXG4gICAgICAgIGNvbnN0IHN0YXRlbGVzc0hvc3RzQXZhaWxhYmxlID0gaG9zdHNBdmFpbGFibGUubGVuZ3RoID4gMFxyXG4gICAgICAgICAgICA/IGhvc3RzQXZhaWxhYmxlLm1hcChob3N0ID0+IGNyZWF0ZVN0YXRlbGVzc0hvc3QoaG9zdCkpXHJcbiAgICAgICAgICAgIDogc3RhdGVsZXNzSG9zdHM7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZ2V0VGltZW91dCh0aW1lb3V0c0NvdW50LCBiYXNlVGltZW91dCkge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBJbWFnaW5lIHRoYXQgeW91IGhhdmUgNCBob3N0cywgaWYgdGltZW91dHMgd2lsbCBpbmNyZWFzZVxyXG4gICAgICAgICAgICAgICAgICogb24gdGhlIGZvbGxvd2luZyB3YXk6IDEgKHRpbWVvdXRlZCkgPiA0ICh0aW1lb3V0ZWQpID4gNSAoMjAwKVxyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCwgdGhlIHZlcnkgbmV4dCByZXF1ZXN0LCB3ZSBzdGFydCBmcm9tIHRoZSBwcmV2aW91cyB0aW1lb3V0XHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogIDUgKHRpbWVvdXRlZCkgPiA2ICh0aW1lb3V0ZWQpID4gNyAuLi5cclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGlzIHN0cmF0ZWd5IG1heSBuZWVkIHRvIGJlIHJldmlld2VkLCBidXQgaXMgdGhlIHN0cmF0ZWd5IG9uIHRoZSBvdXJcclxuICAgICAgICAgICAgICAgICAqIGN1cnJlbnQgdjMgdmVyc2lvbi5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGltZW91dE11bHRpcGxpZXIgPSBob3N0c1RpbWVvdXRlZC5sZW5ndGggPT09IDAgJiYgdGltZW91dHNDb3VudCA9PT0gMFxyXG4gICAgICAgICAgICAgICAgICAgID8gMVxyXG4gICAgICAgICAgICAgICAgICAgIDogaG9zdHNUaW1lb3V0ZWQubGVuZ3RoICsgMyArIHRpbWVvdXRzQ291bnQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGltZW91dE11bHRpcGxpZXIgKiBiYXNlVGltZW91dDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3RhdGVsZXNzSG9zdHM6IHN0YXRlbGVzc0hvc3RzQXZhaWxhYmxlLFxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxufVxuXG5jb25zdCBpc05ldHdvcmtFcnJvciA9ICh7IGlzVGltZWRPdXQsIHN0YXR1cyB9KSA9PiB7XHJcbiAgICByZXR1cm4gIWlzVGltZWRPdXQgJiYgfn5zdGF0dXMgPT09IDA7XHJcbn07XHJcbmNvbnN0IGlzUmV0cnlhYmxlID0gKHJlc3BvbnNlKSA9PiB7XHJcbiAgICBjb25zdCBzdGF0dXMgPSByZXNwb25zZS5zdGF0dXM7XHJcbiAgICBjb25zdCBpc1RpbWVkT3V0ID0gcmVzcG9uc2UuaXNUaW1lZE91dDtcclxuICAgIHJldHVybiAoaXNUaW1lZE91dCB8fCBpc05ldHdvcmtFcnJvcihyZXNwb25zZSkgfHwgKH5+KHN0YXR1cyAvIDEwMCkgIT09IDIgJiYgfn4oc3RhdHVzIC8gMTAwKSAhPT0gNCkpO1xyXG59O1xyXG5jb25zdCBpc1N1Y2Nlc3MgPSAoeyBzdGF0dXMgfSkgPT4ge1xyXG4gICAgcmV0dXJuIH5+KHN0YXR1cyAvIDEwMCkgPT09IDI7XHJcbn07XHJcbmNvbnN0IHJldHJ5RGVjaXNpb24gPSAocmVzcG9uc2UsIG91dGNvbWVzKSA9PiB7XHJcbiAgICBpZiAoaXNSZXRyeWFibGUocmVzcG9uc2UpKSB7XHJcbiAgICAgICAgcmV0dXJuIG91dGNvbWVzLm9uUmV0cnkocmVzcG9uc2UpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzU3VjY2VzcyhyZXNwb25zZSkpIHtcclxuICAgICAgICByZXR1cm4gb3V0Y29tZXMub25TdWNjZXNzKHJlc3BvbnNlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBvdXRjb21lcy5vbkZhaWwocmVzcG9uc2UpO1xyXG59O1xuXG5mdW5jdGlvbiByZXRyeWFibGVSZXF1ZXN0KHRyYW5zcG9ydGVyLCBzdGF0ZWxlc3NIb3N0cywgcmVxdWVzdCwgcmVxdWVzdE9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHN0YWNrVHJhY2UgPSBbXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmdW5jdGlvbmFsL3ByZWZlci1yZWFkb25seS10eXBlXHJcbiAgICAvKipcclxuICAgICAqIEZpcnN0IHdlIHByZXBhcmUgdGhlIHBheWxvYWQgdGhhdCBkbyBub3QgZGVwZW5kIGZyb20gaG9zdHMuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGRhdGEgPSBzZXJpYWxpemVEYXRhKHJlcXVlc3QsIHJlcXVlc3RPcHRpb25zKTtcclxuICAgIGNvbnN0IGhlYWRlcnMgPSBzZXJpYWxpemVIZWFkZXJzKHRyYW5zcG9ydGVyLCByZXF1ZXN0T3B0aW9ucyk7XHJcbiAgICBjb25zdCBtZXRob2QgPSByZXF1ZXN0Lm1ldGhvZDtcclxuICAgIC8vIE9uIGBHRVRgLCB0aGUgZGF0YSBpcyBwcm94aWVkIHRvIHF1ZXJ5IHBhcmFtZXRlcnMuXHJcbiAgICBjb25zdCBkYXRhUXVlcnlQYXJhbWV0ZXJzID0gcmVxdWVzdC5tZXRob2QgIT09IE1ldGhvZEVudW0uR2V0XHJcbiAgICAgICAgPyB7fVxyXG4gICAgICAgIDoge1xyXG4gICAgICAgICAgICAuLi5yZXF1ZXN0LmRhdGEsXHJcbiAgICAgICAgICAgIC4uLnJlcXVlc3RPcHRpb25zLmRhdGEsXHJcbiAgICAgICAgfTtcclxuICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHtcclxuICAgICAgICAneC1hbGdvbGlhLWFnZW50JzogdHJhbnNwb3J0ZXIudXNlckFnZW50LnZhbHVlLFxyXG4gICAgICAgIC4uLnRyYW5zcG9ydGVyLnF1ZXJ5UGFyYW1ldGVycyxcclxuICAgICAgICAuLi5kYXRhUXVlcnlQYXJhbWV0ZXJzLFxyXG4gICAgICAgIC4uLnJlcXVlc3RPcHRpb25zLnF1ZXJ5UGFyYW1ldGVycyxcclxuICAgIH07XHJcbiAgICBsZXQgdGltZW91dHNDb3VudCA9IDA7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZnVuY3Rpb25hbC9uby1sZXRcclxuICAgIGNvbnN0IHJldHJ5ID0gKGhvc3RzLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmN0aW9uYWwvcHJlZmVyLXJlYWRvbmx5LXR5cGVcclxuICAgIGdldFRpbWVvdXQpID0+IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXZSBpdGVyYXRlIG9uIGVhY2ggaG9zdCwgdW50aWwgdGhlcmUgaXMgbm8gaG9zdCBsZWZ0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNvbnN0IGhvc3QgPSBob3N0cy5wb3AoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmdW5jdGlvbmFsL2ltbXV0YWJsZS1kYXRhXHJcbiAgICAgICAgaWYgKGhvc3QgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVSZXRyeUVycm9yKHN0YWNrVHJhY2VXaXRob3V0Q3JlZGVudGlhbHMoc3RhY2tUcmFjZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwYXlsb2FkID0ge1xyXG4gICAgICAgICAgICBkYXRhLFxyXG4gICAgICAgICAgICBoZWFkZXJzLFxyXG4gICAgICAgICAgICBtZXRob2QsXHJcbiAgICAgICAgICAgIHVybDogc2VyaWFsaXplVXJsKGhvc3QsIHJlcXVlc3QucGF0aCwgcXVlcnlQYXJhbWV0ZXJzKSxcclxuICAgICAgICAgICAgY29ubmVjdFRpbWVvdXQ6IGdldFRpbWVvdXQodGltZW91dHNDb3VudCwgdHJhbnNwb3J0ZXIudGltZW91dHMuY29ubmVjdCksXHJcbiAgICAgICAgICAgIHJlc3BvbnNlVGltZW91dDogZ2V0VGltZW91dCh0aW1lb3V0c0NvdW50LCByZXF1ZXN0T3B0aW9ucy50aW1lb3V0KSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBzdGFja0ZyYW1lIGlzIHB1c2hlZCB0byB0aGUgc3RhY2tUcmFjZSBzbyB3ZVxyXG4gICAgICAgICAqIGNhbiBoYXZlIGluZm9ybWF0aW9uIGFib3V0IG9uUmV0cnkgYW5kIG9uRmFpbHVyZVxyXG4gICAgICAgICAqIGRlY2lzaW9ucy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjb25zdCBwdXNoVG9TdGFja1RyYWNlID0gKHJlc3BvbnNlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YWNrRnJhbWUgPSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiBwYXlsb2FkLFxyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UsXHJcbiAgICAgICAgICAgICAgICBob3N0LFxyXG4gICAgICAgICAgICAgICAgdHJpZXNMZWZ0OiBob3N0cy5sZW5ndGgsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jdGlvbmFsL2ltbXV0YWJsZS1kYXRhXHJcbiAgICAgICAgICAgIHN0YWNrVHJhY2UucHVzaChzdGFja0ZyYW1lKTtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YWNrRnJhbWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBkZWNpc2lvbnMgPSB7XHJcbiAgICAgICAgICAgIG9uU3VjY2VzczogcmVzcG9uc2UgPT4gZGVzZXJpYWxpemVTdWNjZXNzKHJlc3BvbnNlKSxcclxuICAgICAgICAgICAgb25SZXRyeShyZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhY2tGcmFtZSA9IHB1c2hUb1N0YWNrVHJhY2UocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBJZiByZXNwb25zZSBpcyBhIHRpbWVvdXQsIHdlIGluY3JlYXNldCB0aGUgbnVtYmVyIG9mXHJcbiAgICAgICAgICAgICAgICAgKiB0aW1lb3V0cyBzbyB3ZSBjYW4gaW5jcmVhc2UgdGhlIHRpbWVvdXQgbGF0ZXIuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5pc1RpbWVkT3V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dHNDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBGYWlsdXJlcyBhcmUgaW5kaXZpZHVhbGx5IHNlbmQgdGhlIGxvZ2dlciwgYWxsb3dpbmdcclxuICAgICAgICAgICAgICAgICAgICAgKiB0aGUgZW5kIHVzZXIgdG8gZGVidWcgLyBzdG9yZSBzdGFjayBmcmFtZXMgZXZlblxyXG4gICAgICAgICAgICAgICAgICAgICAqIHdoZW4gYSByZXRyeSBlcnJvciBkb2VzIG5vdCBoYXBwZW4uXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0ZXIubG9nZ2VyLmluZm8oJ1JldHJ5YWJsZSBmYWlsdXJlJywgc3RhY2tGcmFtZVdpdGhvdXRDcmVkZW50aWFscyhzdGFja0ZyYW1lKSksXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogV2UgYWxzbyBzdG9yZSB0aGUgc3RhdGUgb2YgdGhlIGhvc3QgaW4gZmFpbHVyZSBjYXNlcy4gSWYgdGhlIGhvc3QsIGlzXHJcbiAgICAgICAgICAgICAgICAgICAgICogZG93biBpdCB3aWxsIHJlbWFpbiBkb3duIGZvciB0aGUgbmV4dCAyIG1pbnV0ZXMuIEluIGEgdGltZW91dCBzaXR1YXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICogdGhpcyBob3N0IHdpbGwgYmUgYWRkZWQgZW5kIG9mIHRoZSBsaXN0IG9mIGhvc3RzIG9uIHRoZSBuZXh0IHJlcXVlc3QuXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0ZXIuaG9zdHNDYWNoZS5zZXQoaG9zdCwgY3JlYXRlU3RhdGVmdWxIb3N0KGhvc3QsIHJlc3BvbnNlLmlzVGltZWRPdXQgPyBIb3N0U3RhdHVzRW51bS5UaW1lb3V0ZWQgOiBIb3N0U3RhdHVzRW51bS5Eb3duKSksXHJcbiAgICAgICAgICAgICAgICBdKS50aGVuKCgpID0+IHJldHJ5KGhvc3RzLCBnZXRUaW1lb3V0KSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uRmFpbChyZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgcHVzaFRvU3RhY2tUcmFjZShyZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBkZXNlcmlhbGl6ZUZhaWx1cmUocmVzcG9uc2UsIHN0YWNrVHJhY2VXaXRob3V0Q3JlZGVudGlhbHMoc3RhY2tUcmFjZSkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHRyYW5zcG9ydGVyLnJlcXVlc3Rlci5zZW5kKHBheWxvYWQpLnRoZW4ocmVzcG9uc2UgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gcmV0cnlEZWNpc2lvbihyZXNwb25zZSwgZGVjaXNpb25zKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEZpbmFsbHksIGZvciBlYWNoIHJldHJ5YWJsZSBob3N0IHBlcmZvcm0gcmVxdWVzdCB1bnRpbCB3ZSBnb3QgYSBub25cclxuICAgICAqIHJldHJ5YWJsZSByZXNwb25zZS4gU29tZSBub3RlcyBoZXJlOlxyXG4gICAgICpcclxuICAgICAqIDEuIFRoZSByZXZlcnNlIGhlcmUgaXMgYXBwbGllZCBzbyB3ZSBjYW4gYXBwbHkgYSBgcG9wYCBsYXRlciBvbiA9PiBtb3JlIHBlcmZvcm1hbnQuXHJcbiAgICAgKiAyLiBXZSBhbHNvIGdldCBmcm9tIHRoZSByZXRyeWFibGUgb3B0aW9ucyBhIHRpbWVvdXQgbXVsdGlwbGllciB0aGF0IGlzIHRhaWxvcmVkXHJcbiAgICAgKiBmb3IgdGhlIGN1cnJlbnQgY29udGV4dC5cclxuICAgICAqL1xyXG4gICAgcmV0dXJuIGNyZWF0ZVJldHJ5YWJsZU9wdGlvbnModHJhbnNwb3J0ZXIuaG9zdHNDYWNoZSwgc3RhdGVsZXNzSG9zdHMpLnRoZW4ob3B0aW9ucyA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHJldHJ5KFsuLi5vcHRpb25zLnN0YXRlbGVzc0hvc3RzXS5yZXZlcnNlKCksIG9wdGlvbnMuZ2V0VGltZW91dCk7XHJcbiAgICB9KTtcclxufVxuXG5mdW5jdGlvbiBjcmVhdGVUcmFuc3BvcnRlcihvcHRpb25zKSB7XHJcbiAgICBjb25zdCB7IGhvc3RzQ2FjaGUsIGxvZ2dlciwgcmVxdWVzdGVyLCByZXF1ZXN0c0NhY2hlLCByZXNwb25zZXNDYWNoZSwgdGltZW91dHMsIHVzZXJBZ2VudCwgaG9zdHMsIHF1ZXJ5UGFyYW1ldGVycywgaGVhZGVycywgfSA9IG9wdGlvbnM7XHJcbiAgICBjb25zdCB0cmFuc3BvcnRlciA9IHtcclxuICAgICAgICBob3N0c0NhY2hlLFxyXG4gICAgICAgIGxvZ2dlcixcclxuICAgICAgICByZXF1ZXN0ZXIsXHJcbiAgICAgICAgcmVxdWVzdHNDYWNoZSxcclxuICAgICAgICByZXNwb25zZXNDYWNoZSxcclxuICAgICAgICB0aW1lb3V0cyxcclxuICAgICAgICB1c2VyQWdlbnQsXHJcbiAgICAgICAgaGVhZGVycyxcclxuICAgICAgICBxdWVyeVBhcmFtZXRlcnMsXHJcbiAgICAgICAgaG9zdHM6IGhvc3RzLm1hcChob3N0ID0+IGNyZWF0ZVN0YXRlbGVzc0hvc3QoaG9zdCkpLFxyXG4gICAgICAgIHJlYWQocmVxdWVzdCwgcmVxdWVzdE9wdGlvbnMpIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEZpcnN0LCB3ZSBjb21wdXRlIHRoZSB1c2VyIHJlcXVlc3Qgb3B0aW9ucy4gTm93LCBrZWVwIGluIG1pbmQsXHJcbiAgICAgICAgICAgICAqIHRoYXQgdXNpbmcgcmVxdWVzdCBvcHRpb25zIHRoZSB1c2VyIGlzIGFibGUgdG8gbW9kaWZpZWQgdGhlIGludGlyZVxyXG4gICAgICAgICAgICAgKiBwYXlsb2FkIG9mIHRoZSByZXF1ZXN0LiBTdWNoIGFzIGhlYWRlcnMsIHF1ZXJ5IHBhcmFtZXRlcnMsIGFuZCBvdGhlcnMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBjb25zdCBtYXBwZWRSZXF1ZXN0T3B0aW9ucyA9IGNyZWF0ZU1hcHBlZFJlcXVlc3RPcHRpb25zKHJlcXVlc3RPcHRpb25zLCB0cmFuc3BvcnRlci50aW1lb3V0cy5yZWFkKTtcclxuICAgICAgICAgICAgY29uc3QgY3JlYXRlUmV0cnlhYmxlUmVxdWVzdCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlbiwgd2UgcHJlcGFyZSBhIGZ1bmN0aW9uIGZhY3RvcnkgdGhhdCBjb250YWlucyB0aGUgY29uc3RydWN0aW9uIG9mXHJcbiAgICAgICAgICAgICAgICAgKiB0aGUgcmV0cnlhYmxlIHJlcXVlc3QuIEF0IHRoaXMgcG9pbnQsIHdlIG1heSAqbm90KiBwZXJmb3JtIHRoZSBhY3R1YWxcclxuICAgICAgICAgICAgICAgICAqIHJlcXVlc3QuIEJ1dCB3ZSB3YW50IHRvIGhhdmUgdGhlIGZ1bmN0aW9uIGZhY3RvcnkgcmVhZHkuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXRyeWFibGVSZXF1ZXN0KHRyYW5zcG9ydGVyLCB0cmFuc3BvcnRlci5ob3N0cy5maWx0ZXIoaG9zdCA9PiAoaG9zdC5hY2NlcHQgJiBDYWxsRW51bS5SZWFkKSAhPT0gMCksIHJlcXVlc3QsIG1hcHBlZFJlcXVlc3RPcHRpb25zKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE9uY2Ugd2UgaGF2ZSB0aGUgZnVuY3Rpb24gZmFjdG9yeSByZWFkeSwgd2UgbmVlZCB0byBkZXRlcm1pbmUgb2YgdGhlXHJcbiAgICAgICAgICAgICAqIHJlcXVlc3QgaXMgXCJjYWNoZWFibGVcIiAtIHNob3VsZCBiZSBjYWNoZWQuIE5vdGUgdGhhdCwgb25jZSBhZ2FpbixcclxuICAgICAgICAgICAgICogdGhlIHVzZXIgY2FuIGZvcmNlIHRoaXMgb3B0aW9uLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgY29uc3QgY2FjaGVhYmxlID0gbWFwcGVkUmVxdWVzdE9wdGlvbnMuY2FjaGVhYmxlICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgID8gbWFwcGVkUmVxdWVzdE9wdGlvbnMuY2FjaGVhYmxlXHJcbiAgICAgICAgICAgICAgICA6IHJlcXVlc3QuY2FjaGVhYmxlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSWYgaXMgbm90IFwiY2FjaGVhYmxlXCIsIHdlIGltbWVkaWF0bHkgdHJpZ2dlciB0aGUgcmV0cnlhYmxlIHJlcXVlc3QsIG5vXHJcbiAgICAgICAgICAgICAqIG5lZWQgdG8gY2hlY2sgY2FjaGUgaW1wbGVtZW50YXRpb25zLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgaWYgKGNhY2hlYWJsZSAhPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVJldHJ5YWJsZVJlcXVlc3QoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSWYgdGhlIHJlcXVlc3QgaXMgXCJjYWNoZWFibGVcIiwgd2UgbmVlZCB0byBmaXJzdCBjb21wdXRlIHRoZSBrZXkgdG8gYXNrXHJcbiAgICAgICAgICAgICAqIHRoZSBjYWNoZSBpbXBsZW1lbnRhdGlvbnMgaWYgdGhpcyByZXF1ZXN0IGlzIG9uIHByb2dyZXNzIG9yIGlmIHRoZVxyXG4gICAgICAgICAgICAgKiByZXNwb25zZSBhbHJlYWR5IGV4aXN0cyBvbiB0aGUgY2FjaGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxyXG4gICAgICAgICAgICAgICAgbWFwcGVkUmVxdWVzdE9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnRlcjoge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyczogdHJhbnNwb3J0ZXIucXVlcnlQYXJhbWV0ZXJzLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRyYW5zcG9ydGVyLmhlYWRlcnMsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2l0aCB0aGUgY29tcHV0ZWQga2V5LCB3ZSBmaXJzdCBhc2sgdGhlIHJlc3BvbnNlcyBjYWNoZVxyXG4gICAgICAgICAgICAgKiBpbXBsZW1lbnRpb24gaWYgdGhpcyByZXF1ZXN0IHdhcyBiZWVuIHJlc29sdmVkIGJlZm9yZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHJldHVybiB0cmFuc3BvcnRlci5yZXNwb25zZXNDYWNoZS5nZXQoa2V5LCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIElmIHRoZSByZXF1ZXN0IGhhcyBuZXZlciByZXNvbHZlZCBiZWZvcmUsIHdlIGFjdHVhbGx5IGFzayBpZiB0aGVyZVxyXG4gICAgICAgICAgICAgICAgICogaXMgYSBjdXJyZW50IHJlcXVlc3Qgd2l0aCB0aGUgc2FtZSBrZXkgb24gcHJvZ3Jlc3MuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc3BvcnRlci5yZXF1ZXN0c0NhY2hlLmdldChrZXksICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRyYW5zcG9ydGVyLnJlcXVlc3RzQ2FjaGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEZpbmFsbHksIGlmIHRoZXJlIGlzIG5vIHJlcXVlc3QgaW4gcHJvZ3Jlc3Mgd2l0aCB0aGUgc2FtZSBrZXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHRoaXMgYGNyZWF0ZVJldHJ5YWJsZVJlcXVlc3QoKWAgd2lsbCBhY3R1YWxseSB0cmlnZ2VyIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiByZXRyeWFibGUgcmVxdWVzdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXQoa2V5LCBjcmVhdGVSZXRyeWFibGVSZXF1ZXN0KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IFByb21pc2UuYWxsKFt0cmFuc3BvcnRlci5yZXF1ZXN0c0NhY2hlLmRlbGV0ZShrZXkpLCByZXNwb25zZV0pLCBlcnIgPT4gUHJvbWlzZS5hbGwoW3RyYW5zcG9ydGVyLnJlcXVlc3RzQ2FjaGUuZGVsZXRlKGtleSksIFByb21pc2UucmVqZWN0KGVycildKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKFtfLCByZXNwb25zZV0pID0+IHJlc3BvbnNlKSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSwge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBPZiBjb3Vyc2UsIG9uY2Ugd2UgZ2V0IHRoaXMgcmVzcG9uc2UgYmFjayBmcm9tIHRoZSBzZXJ2ZXIsIHdlXHJcbiAgICAgICAgICAgICAgICAgKiB0ZWxsIHJlc3BvbnNlIGNhY2hlIHRvIGFjdHVhbGx5IHN0b3JlIHRoZSByZWNlaXZlZCByZXNwb25zZVxyXG4gICAgICAgICAgICAgICAgICogdG8gYmUgdXNlZCBsYXRlci5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgbWlzczogcmVzcG9uc2UgPT4gdHJhbnNwb3J0ZXIucmVzcG9uc2VzQ2FjaGUuc2V0KGtleSwgcmVzcG9uc2UpLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHdyaXRlKHJlcXVlc3QsIHJlcXVlc3RPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBPbiB3cml0ZSByZXF1ZXN0cywgbm8gY2FjaGUgbWVjaGFuaXNtcyBhcmUgYXBwbGllZCwgYW5kIHdlXHJcbiAgICAgICAgICAgICAqIHByb3h5IHRoZSByZXF1ZXN0IGltbWVkaWF0ZWx5IHRvIHRoZSByZXF1ZXN0ZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICByZXR1cm4gcmV0cnlhYmxlUmVxdWVzdCh0cmFuc3BvcnRlciwgdHJhbnNwb3J0ZXIuaG9zdHMuZmlsdGVyKGhvc3QgPT4gKGhvc3QuYWNjZXB0ICYgQ2FsbEVudW0uV3JpdGUpICE9PSAwKSwgcmVxdWVzdCwgY3JlYXRlTWFwcGVkUmVxdWVzdE9wdGlvbnMocmVxdWVzdE9wdGlvbnMsIHRyYW5zcG9ydGVyLnRpbWVvdXRzLndyaXRlKSk7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbiAgICByZXR1cm4gdHJhbnNwb3J0ZXI7XHJcbn1cblxuZnVuY3Rpb24gY3JlYXRlVXNlckFnZW50KHZlcnNpb24pIHtcclxuICAgIGNvbnN0IHVzZXJBZ2VudCA9IHtcclxuICAgICAgICB2YWx1ZTogYEFsZ29saWEgZm9yIEphdmFTY3JpcHQgKCR7dmVyc2lvbn0pYCxcclxuICAgICAgICBhZGQob3B0aW9ucykge1xyXG4gICAgICAgICAgICBjb25zdCBhZGRlZFVzZXJBZ2VudCA9IGA7ICR7b3B0aW9ucy5zZWdtZW50fSR7b3B0aW9ucy52ZXJzaW9uICE9PSB1bmRlZmluZWQgPyBgICgke29wdGlvbnMudmVyc2lvbn0pYCA6ICcnfWA7XHJcbiAgICAgICAgICAgIGlmICh1c2VyQWdlbnQudmFsdWUuaW5kZXhPZihhZGRlZFVzZXJBZ2VudCkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9pbW11dGFibGUtZGF0YVxyXG4gICAgICAgICAgICAgICAgdXNlckFnZW50LnZhbHVlID0gYCR7dXNlckFnZW50LnZhbHVlfSR7YWRkZWRVc2VyQWdlbnR9YDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdXNlckFnZW50O1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHVzZXJBZ2VudDtcclxufVxuXG5mdW5jdGlvbiBkZXNlcmlhbGl6ZVN1Y2Nlc3MocmVzcG9uc2UpIHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jdGlvbmFsL25vLXRyeS1zdGF0ZW1lbnRcclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmVzcG9uc2UuY29udGVudCk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIHRocm93IGNyZWF0ZURlc2VyaWFsaXphdGlvbkVycm9yKGUubWVzc2FnZSwgcmVzcG9uc2UpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGRlc2VyaWFsaXplRmFpbHVyZSh7IGNvbnRlbnQsIHN0YXR1cyB9LCBzdGFja0ZyYW1lKSB7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9uby1sZXRcclxuICAgIGxldCBtZXNzYWdlID0gY29udGVudDtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jdGlvbmFsL25vLXRyeS1zdGF0ZW1lbnRcclxuICAgIHRyeSB7XHJcbiAgICAgICAgbWVzc2FnZSA9IEpTT04ucGFyc2UoY29udGVudCkubWVzc2FnZTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgLy8gLi5cclxuICAgIH1cclxuICAgIHJldHVybiBjcmVhdGVBcGlFcnJvcihtZXNzYWdlLCBzdGF0dXMsIHN0YWNrRnJhbWUpO1xyXG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZVVybChob3N0LCBwYXRoLCBxdWVyeVBhcmFtZXRlcnMpIHtcclxuICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVyc0FzU3RyaW5nID0gc2VyaWFsaXplUXVlcnlQYXJhbWV0ZXJzKHF1ZXJ5UGFyYW1ldGVycyk7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9uby1sZXRcclxuICAgIGxldCB1cmwgPSBgJHtob3N0LnByb3RvY29sfTovLyR7aG9zdC51cmx9LyR7cGF0aC5jaGFyQXQoMCkgPT09ICcvJyA/IHBhdGguc3Vic3RyKDEpIDogcGF0aH1gO1xyXG4gICAgaWYgKHF1ZXJ5UGFyYW1ldGVyc0FzU3RyaW5nLmxlbmd0aCkge1xyXG4gICAgICAgIHVybCArPSBgPyR7cXVlcnlQYXJhbWV0ZXJzQXNTdHJpbmd9YDtcclxuICAgIH1cclxuICAgIHJldHVybiB1cmw7XHJcbn1cclxuZnVuY3Rpb24gc2VyaWFsaXplUXVlcnlQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpIHtcclxuICAgIGNvbnN0IGlzT2JqZWN0T3JBcnJheSA9ICh2YWx1ZSkgPT4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgfHxcclxuICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nO1xyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHBhcmFtZXRlcnMpXHJcbiAgICAgICAgLm1hcChrZXkgPT4gZW5jb2RlKCclcz0lcycsIGtleSwgaXNPYmplY3RPckFycmF5KHBhcmFtZXRlcnNba2V5XSkgPyBKU09OLnN0cmluZ2lmeShwYXJhbWV0ZXJzW2tleV0pIDogcGFyYW1ldGVyc1trZXldKSlcclxuICAgICAgICAuam9pbignJicpO1xyXG59XHJcbmZ1bmN0aW9uIHNlcmlhbGl6ZURhdGEocmVxdWVzdCwgcmVxdWVzdE9wdGlvbnMpIHtcclxuICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gTWV0aG9kRW51bS5HZXQgfHxcclxuICAgICAgICAocmVxdWVzdC5kYXRhID09PSB1bmRlZmluZWQgJiYgcmVxdWVzdE9wdGlvbnMuZGF0YSA9PT0gdW5kZWZpbmVkKSkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBjb25zdCBkYXRhID0gQXJyYXkuaXNBcnJheShyZXF1ZXN0LmRhdGEpXHJcbiAgICAgICAgPyByZXF1ZXN0LmRhdGFcclxuICAgICAgICA6IHsgLi4ucmVxdWVzdC5kYXRhLCAuLi5yZXF1ZXN0T3B0aW9ucy5kYXRhIH07XHJcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XHJcbn1cclxuZnVuY3Rpb24gc2VyaWFsaXplSGVhZGVycyh0cmFuc3BvcnRlciwgcmVxdWVzdE9wdGlvbnMpIHtcclxuICAgIGNvbnN0IGhlYWRlcnMgPSB7XHJcbiAgICAgICAgLi4udHJhbnNwb3J0ZXIuaGVhZGVycyxcclxuICAgICAgICAuLi5yZXF1ZXN0T3B0aW9ucy5oZWFkZXJzLFxyXG4gICAgfTtcclxuICAgIGNvbnN0IHNlcmlhbGl6ZWRIZWFkZXJzID0ge307XHJcbiAgICBPYmplY3Qua2V5cyhoZWFkZXJzKS5mb3JFYWNoKGhlYWRlciA9PiB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBoZWFkZXJzW2hlYWRlcl07XHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jdGlvbmFsL2ltbXV0YWJsZS1kYXRhXHJcbiAgICAgICAgc2VyaWFsaXplZEhlYWRlcnNbaGVhZGVyLnRvTG93ZXJDYXNlKCldID0gdmFsdWU7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBzZXJpYWxpemVkSGVhZGVycztcclxufVxuXG5mdW5jdGlvbiBzdGFja1RyYWNlV2l0aG91dENyZWRlbnRpYWxzKHN0YWNrVHJhY2UpIHtcclxuICAgIHJldHVybiBzdGFja1RyYWNlLm1hcChzdGFja0ZyYW1lID0+IHN0YWNrRnJhbWVXaXRob3V0Q3JlZGVudGlhbHMoc3RhY2tGcmFtZSkpO1xyXG59XHJcbmZ1bmN0aW9uIHN0YWNrRnJhbWVXaXRob3V0Q3JlZGVudGlhbHMoc3RhY2tGcmFtZSkge1xyXG4gICAgY29uc3QgbW9kaWZpZWRIZWFkZXJzID0gc3RhY2tGcmFtZS5yZXF1ZXN0LmhlYWRlcnNbJ3gtYWxnb2xpYS1hcGkta2V5J11cclxuICAgICAgICA/IHsgJ3gtYWxnb2xpYS1hcGkta2V5JzogJyoqKioqJyB9XHJcbiAgICAgICAgOiB7fTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgLi4uc3RhY2tGcmFtZSxcclxuICAgICAgICByZXF1ZXN0OiB7XHJcbiAgICAgICAgICAgIC4uLnN0YWNrRnJhbWUucmVxdWVzdCxcclxuICAgICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICAgLi4uc3RhY2tGcmFtZS5yZXF1ZXN0LmhlYWRlcnMsXHJcbiAgICAgICAgICAgICAgICAuLi5tb2RpZmllZEhlYWRlcnMsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXBpRXJyb3IobWVzc2FnZSwgc3RhdHVzLCB0cmFuc3BvcnRlclN0YWNrVHJhY2UpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmFtZTogJ0FwaUVycm9yJyxcclxuICAgICAgICBtZXNzYWdlLFxyXG4gICAgICAgIHN0YXR1cyxcclxuICAgICAgICB0cmFuc3BvcnRlclN0YWNrVHJhY2UsXHJcbiAgICB9O1xyXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURlc2VyaWFsaXphdGlvbkVycm9yKG1lc3NhZ2UsIHJlc3BvbnNlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5hbWU6ICdEZXNlcmlhbGl6YXRpb25FcnJvcicsXHJcbiAgICAgICAgbWVzc2FnZSxcclxuICAgICAgICByZXNwb25zZSxcclxuICAgIH07XHJcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmV0cnlFcnJvcih0cmFuc3BvcnRlclN0YWNrVHJhY2UpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmFtZTogJ1JldHJ5RXJyb3InLFxyXG4gICAgICAgIG1lc3NhZ2U6ICdVbnJlYWNoYWJsZSBob3N0cyAtIHlvdXIgYXBwbGljYXRpb24gaWQgbWF5IGJlIGluY29ycmVjdC4gSWYgdGhlIGVycm9yIHBlcnNpc3RzLCBjb250YWN0IHN1cHBvcnRAYWxnb2xpYS5jb20uJyxcclxuICAgICAgICB0cmFuc3BvcnRlclN0YWNrVHJhY2UsXHJcbiAgICB9O1xyXG59XG5cbmNvbnN0IGNyZWF0ZVNlYXJjaENsaWVudCA9IG9wdGlvbnMgPT4ge1xyXG4gICAgY29uc3QgYXBwSWQgPSBvcHRpb25zLmFwcElkO1xyXG4gICAgY29uc3QgYXV0aCA9IGNyZWF0ZUF1dGgob3B0aW9ucy5hdXRoTW9kZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hdXRoTW9kZSA6IEF1dGhNb2RlLldpdGhpbkhlYWRlcnMsIGFwcElkLCBvcHRpb25zLmFwaUtleSk7XHJcbiAgICBjb25zdCB0cmFuc3BvcnRlciA9IGNyZWF0ZVRyYW5zcG9ydGVyKHtcclxuICAgICAgICBob3N0czogW1xyXG4gICAgICAgICAgICB7IHVybDogYCR7YXBwSWR9LWRzbi5hbGdvbGlhLm5ldGAsIGFjY2VwdDogQ2FsbEVudW0uUmVhZCB9LFxyXG4gICAgICAgICAgICB7IHVybDogYCR7YXBwSWR9LmFsZ29saWEubmV0YCwgYWNjZXB0OiBDYWxsRW51bS5Xcml0ZSB9LFxyXG4gICAgICAgIF0uY29uY2F0KHNodWZmbGUoW1xyXG4gICAgICAgICAgICB7IHVybDogYCR7YXBwSWR9LTEuYWxnb2xpYW5ldC5jb21gIH0sXHJcbiAgICAgICAgICAgIHsgdXJsOiBgJHthcHBJZH0tMi5hbGdvbGlhbmV0LmNvbWAgfSxcclxuICAgICAgICAgICAgeyB1cmw6IGAke2FwcElkfS0zLmFsZ29saWFuZXQuY29tYCB9LFxyXG4gICAgICAgIF0pKSxcclxuICAgICAgICAuLi5vcHRpb25zLFxyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgLi4uYXV0aC5oZWFkZXJzKCksXHJcbiAgICAgICAgICAgIC4uLnsgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnIH0sXHJcbiAgICAgICAgICAgIC4uLm9wdGlvbnMuaGVhZGVycyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHF1ZXJ5UGFyYW1ldGVyczoge1xyXG4gICAgICAgICAgICAuLi5hdXRoLnF1ZXJ5UGFyYW1ldGVycygpLFxyXG4gICAgICAgICAgICAuLi5vcHRpb25zLnF1ZXJ5UGFyYW1ldGVycyxcclxuICAgICAgICB9LFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBiYXNlID0ge1xyXG4gICAgICAgIHRyYW5zcG9ydGVyLFxyXG4gICAgICAgIGFwcElkLFxyXG4gICAgICAgIGFkZEFsZ29saWFBZ2VudChzZWdtZW50LCB2ZXJzaW9uKSB7XHJcbiAgICAgICAgICAgIHRyYW5zcG9ydGVyLnVzZXJBZ2VudC5hZGQoeyBzZWdtZW50LCB2ZXJzaW9uIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2xlYXJDYWNoZSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcclxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydGVyLnJlcXVlc3RzQ2FjaGUuY2xlYXIoKSxcclxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydGVyLnJlc3BvbnNlc0NhY2hlLmNsZWFyKCksXHJcbiAgICAgICAgICAgIF0pLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxuICAgIHJldHVybiBhZGRNZXRob2RzKGJhc2UsIG9wdGlvbnMubWV0aG9kcyk7XHJcbn07XG5cbmNvbnN0IGN1c3RvbVJlcXVlc3QgPSAoYmFzZSkgPT4ge1xyXG4gICAgcmV0dXJuIChyZXF1ZXN0LCByZXF1ZXN0T3B0aW9ucykgPT4ge1xyXG4gICAgICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gTWV0aG9kRW51bS5HZXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJhc2UudHJhbnNwb3J0ZXIucmVhZChyZXF1ZXN0LCByZXF1ZXN0T3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBiYXNlLnRyYW5zcG9ydGVyLndyaXRlKHJlcXVlc3QsIHJlcXVlc3RPcHRpb25zKTtcclxuICAgIH07XHJcbn07XG5cbmNvbnN0IGluaXRJbmRleCA9IChiYXNlKSA9PiB7XHJcbiAgICByZXR1cm4gKGluZGV4TmFtZSwgb3B0aW9ucyA9IHt9KSA9PiB7XHJcbiAgICAgICAgY29uc3Qgc2VhcmNoSW5kZXggPSB7XHJcbiAgICAgICAgICAgIHRyYW5zcG9ydGVyOiBiYXNlLnRyYW5zcG9ydGVyLFxyXG4gICAgICAgICAgICBhcHBJZDogYmFzZS5hcHBJZCxcclxuICAgICAgICAgICAgaW5kZXhOYW1lLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIGFkZE1ldGhvZHMoc2VhcmNoSW5kZXgsIG9wdGlvbnMubWV0aG9kcyk7XHJcbiAgICB9O1xyXG59O1xuXG5jb25zdCBtdWx0aXBsZVF1ZXJpZXMgPSAoYmFzZSkgPT4ge1xyXG4gICAgcmV0dXJuIChxdWVyaWVzLCByZXF1ZXN0T3B0aW9ucykgPT4ge1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3RzID0gcXVlcmllcy5tYXAocXVlcnkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgLi4ucXVlcnksXHJcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHNlcmlhbGl6ZVF1ZXJ5UGFyYW1ldGVycyhxdWVyeS5wYXJhbXMgfHwge30pLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBiYXNlLnRyYW5zcG9ydGVyLnJlYWQoe1xyXG4gICAgICAgICAgICBtZXRob2Q6IE1ldGhvZEVudW0uUG9zdCxcclxuICAgICAgICAgICAgcGF0aDogJzEvaW5kZXhlcy8qL3F1ZXJpZXMnLFxyXG4gICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0cyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2FjaGVhYmxlOiB0cnVlLFxyXG4gICAgICAgIH0sIHJlcXVlc3RPcHRpb25zKTtcclxuICAgIH07XHJcbn07XG5cbmNvbnN0IG11bHRpcGxlU2VhcmNoRm9yRmFjZXRWYWx1ZXMgPSAoYmFzZSkgPT4ge1xyXG4gICAgcmV0dXJuIChxdWVyaWVzLCByZXF1ZXN0T3B0aW9ucykgPT4ge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChxdWVyaWVzLm1hcChxdWVyeSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgZmFjZXROYW1lLCBmYWNldFF1ZXJ5LCAuLi5wYXJhbXMgfSA9IHF1ZXJ5LnBhcmFtcztcclxuICAgICAgICAgICAgcmV0dXJuIGluaXRJbmRleChiYXNlKShxdWVyeS5pbmRleE5hbWUsIHtcclxuICAgICAgICAgICAgICAgIG1ldGhvZHM6IHsgc2VhcmNoRm9yRmFjZXRWYWx1ZXMgfSxcclxuICAgICAgICAgICAgfSkuc2VhcmNoRm9yRmFjZXRWYWx1ZXMoZmFjZXROYW1lLCBmYWNldFF1ZXJ5LCB7XHJcbiAgICAgICAgICAgICAgICAuLi5yZXF1ZXN0T3B0aW9ucyxcclxuICAgICAgICAgICAgICAgIC4uLnBhcmFtcyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfTtcclxufTtcblxuY29uc3QgZmluZEFuc3dlcnMgPSAoYmFzZSkgPT4ge1xyXG4gICAgcmV0dXJuIChxdWVyeSwgcXVlcnlMYW5ndWFnZXMsIHJlcXVlc3RPcHRpb25zKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGJhc2UudHJhbnNwb3J0ZXIucmVhZCh7XHJcbiAgICAgICAgICAgIG1ldGhvZDogTWV0aG9kRW51bS5Qb3N0LFxyXG4gICAgICAgICAgICBwYXRoOiBlbmNvZGUoJzEvYW5zd2Vycy8lcy9wcmVkaWN0aW9uJywgYmFzZS5pbmRleE5hbWUpLFxyXG4gICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICBxdWVyeSxcclxuICAgICAgICAgICAgICAgIHF1ZXJ5TGFuZ3VhZ2VzLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjYWNoZWFibGU6IHRydWUsXHJcbiAgICAgICAgfSwgcmVxdWVzdE9wdGlvbnMpO1xyXG4gICAgfTtcclxufTtcblxuY29uc3Qgc2VhcmNoID0gKGJhc2UpID0+IHtcclxuICAgIHJldHVybiAocXVlcnksIHJlcXVlc3RPcHRpb25zKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGJhc2UudHJhbnNwb3J0ZXIucmVhZCh7XHJcbiAgICAgICAgICAgIG1ldGhvZDogTWV0aG9kRW51bS5Qb3N0LFxyXG4gICAgICAgICAgICBwYXRoOiBlbmNvZGUoJzEvaW5kZXhlcy8lcy9xdWVyeScsIGJhc2UuaW5kZXhOYW1lKSxcclxuICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgcXVlcnksXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNhY2hlYWJsZTogdHJ1ZSxcclxuICAgICAgICB9LCByZXF1ZXN0T3B0aW9ucyk7XHJcbiAgICB9O1xyXG59O1xuXG5jb25zdCBzZWFyY2hGb3JGYWNldFZhbHVlcyA9IChiYXNlKSA9PiB7XHJcbiAgICByZXR1cm4gKGZhY2V0TmFtZSwgZmFjZXRRdWVyeSwgcmVxdWVzdE9wdGlvbnMpID0+IHtcclxuICAgICAgICByZXR1cm4gYmFzZS50cmFuc3BvcnRlci5yZWFkKHtcclxuICAgICAgICAgICAgbWV0aG9kOiBNZXRob2RFbnVtLlBvc3QsXHJcbiAgICAgICAgICAgIHBhdGg6IGVuY29kZSgnMS9pbmRleGVzLyVzL2ZhY2V0cy8lcy9xdWVyeScsIGJhc2UuaW5kZXhOYW1lLCBmYWNldE5hbWUpLFxyXG4gICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICBmYWNldFF1ZXJ5LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjYWNoZWFibGU6IHRydWUsXHJcbiAgICAgICAgfSwgcmVxdWVzdE9wdGlvbnMpO1xyXG4gICAgfTtcclxufTtcblxuY29uc3QgTG9nTGV2ZWxFbnVtID0ge1xyXG4gICAgRGVidWc6IDEsXHJcbiAgICBJbmZvOiAyLFxyXG4gICAgRXJyb3I6IDMsXHJcbn07XG5cbi8qIGVzbGludCBuby1jb25zb2xlOiAwICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUNvbnNvbGVMb2dnZXIobG9nTGV2ZWwpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZGVidWcobWVzc2FnZSwgYXJncykge1xyXG4gICAgICAgICAgICBpZiAoTG9nTGV2ZWxFbnVtLkRlYnVnID49IGxvZ0xldmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKG1lc3NhZ2UsIGFyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGluZm8obWVzc2FnZSwgYXJncykge1xyXG4gICAgICAgICAgICBpZiAoTG9nTGV2ZWxFbnVtLkluZm8gPj0gbG9nTGV2ZWwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhtZXNzYWdlLCBhcmdzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlcnJvcihtZXNzYWdlLCBhcmdzKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSwgYXJncyk7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxuXG5mdW5jdGlvbiBjcmVhdGVCcm93c2VyWGhyUmVxdWVzdGVyKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzZW5kKHJlcXVlc3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlUmVxdWVzdGVyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgICAgICAgICBiYXNlUmVxdWVzdGVyLm9wZW4ocmVxdWVzdC5tZXRob2QsIHJlcXVlc3QudXJsLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHJlcXVlc3QuaGVhZGVycykuZm9yRWFjaChrZXkgPT4gYmFzZVJlcXVlc3Rlci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgcmVxdWVzdC5oZWFkZXJzW2tleV0pKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNyZWF0ZVRpbWVvdXQgPSAodGltZW91dCwgY29udGVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVJlcXVlc3Rlci5hYm9ydCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1RpbWVkT3V0OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9LCB0aW1lb3V0ICogMTAwMCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29ubmVjdFRpbWVvdXQgPSBjcmVhdGVUaW1lb3V0KHJlcXVlc3QuY29ubmVjdFRpbWVvdXQsICdDb25uZWN0aW9uIHRpbWVvdXQnKTtcclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jdGlvbmFsL25vLWxldFxyXG4gICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNlVGltZW91dDtcclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jdGlvbmFsL2ltbXV0YWJsZS1kYXRhXHJcbiAgICAgICAgICAgICAgICBiYXNlUmVxdWVzdGVyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYmFzZVJlcXVlc3Rlci5yZWFkeVN0YXRlID4gYmFzZVJlcXVlc3Rlci5PUEVORUQgJiYgcmVzcG9uc2VUaW1lb3V0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNvbm5lY3RUaW1lb3V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VUaW1lb3V0ID0gY3JlYXRlVGltZW91dChyZXF1ZXN0LnJlc3BvbnNlVGltZW91dCwgJ1NvY2tldCB0aW1lb3V0Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jdGlvbmFsL2ltbXV0YWJsZS1kYXRhXHJcbiAgICAgICAgICAgICAgICBiYXNlUmVxdWVzdGVyLm9uZXJyb3IgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYmFzZVJlcXVlc3Rlci5zdGF0dXMgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNvbm5lY3RUaW1lb3V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHJlc3BvbnNlVGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogYmFzZVJlcXVlc3Rlci5yZXNwb25zZVRleHQgfHwgJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBiYXNlUmVxdWVzdGVyLnN0YXR1cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVGltZWRPdXQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLy8gIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jdGlvbmFsL2ltbXV0YWJsZS1kYXRhXHJcbiAgICAgICAgICAgICAgICBiYXNlUmVxdWVzdGVyLm9ubG9hZCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoY29ubmVjdFRpbWVvdXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChyZXNwb25zZVRpbWVvdXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBiYXNlUmVxdWVzdGVyLnJlc3BvbnNlVGV4dCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBiYXNlUmVxdWVzdGVyLnN0YXR1cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNUaW1lZE91dDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgYmFzZVJlcXVlc3Rlci5zZW5kKHJlcXVlc3QuZGF0YSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XG5cbmZ1bmN0aW9uIGFsZ29saWFzZWFyY2goYXBwSWQsIGFwaUtleSwgb3B0aW9ucykge1xyXG4gICAgY29uc3QgY29tbW9uT3B0aW9ucyA9IHtcclxuICAgICAgICBhcHBJZCxcclxuICAgICAgICBhcGlLZXksXHJcbiAgICAgICAgdGltZW91dHM6IHtcclxuICAgICAgICAgICAgY29ubmVjdDogMSxcclxuICAgICAgICAgICAgcmVhZDogMixcclxuICAgICAgICAgICAgd3JpdGU6IDMwLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVxdWVzdGVyOiBjcmVhdGVCcm93c2VyWGhyUmVxdWVzdGVyKCksXHJcbiAgICAgICAgbG9nZ2VyOiBjcmVhdGVDb25zb2xlTG9nZ2VyKExvZ0xldmVsRW51bS5FcnJvciksXHJcbiAgICAgICAgcmVzcG9uc2VzQ2FjaGU6IGNyZWF0ZUluTWVtb3J5Q2FjaGUoKSxcclxuICAgICAgICByZXF1ZXN0c0NhY2hlOiBjcmVhdGVJbk1lbW9yeUNhY2hlKHsgc2VyaWFsaXphYmxlOiBmYWxzZSB9KSxcclxuICAgICAgICBob3N0c0NhY2hlOiBjcmVhdGVGYWxsYmFja2FibGVDYWNoZSh7XHJcbiAgICAgICAgICAgIGNhY2hlczogW1xyXG4gICAgICAgICAgICAgICAgY3JlYXRlQnJvd3NlckxvY2FsU3RvcmFnZUNhY2hlKHsga2V5OiBgJHt2ZXJzaW9ufS0ke2FwcElkfWAgfSksXHJcbiAgICAgICAgICAgICAgICBjcmVhdGVJbk1lbW9yeUNhY2hlKCksXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgdXNlckFnZW50OiBjcmVhdGVVc2VyQWdlbnQodmVyc2lvbikuYWRkKHtcclxuICAgICAgICAgICAgc2VnbWVudDogJ0Jyb3dzZXInLFxyXG4gICAgICAgICAgICB2ZXJzaW9uOiAnbGl0ZScsXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgYXV0aE1vZGU6IEF1dGhNb2RlLldpdGhpblF1ZXJ5UGFyYW1ldGVycyxcclxuICAgIH07XHJcbiAgICByZXR1cm4gY3JlYXRlU2VhcmNoQ2xpZW50KHtcclxuICAgICAgICAuLi5jb21tb25PcHRpb25zLFxyXG4gICAgICAgIC4uLm9wdGlvbnMsXHJcbiAgICAgICAgbWV0aG9kczoge1xyXG4gICAgICAgICAgICBzZWFyY2g6IG11bHRpcGxlUXVlcmllcyxcclxuICAgICAgICAgICAgc2VhcmNoRm9yRmFjZXRWYWx1ZXM6IG11bHRpcGxlU2VhcmNoRm9yRmFjZXRWYWx1ZXMsXHJcbiAgICAgICAgICAgIG11bHRpcGxlUXVlcmllcyxcclxuICAgICAgICAgICAgbXVsdGlwbGVTZWFyY2hGb3JGYWNldFZhbHVlcyxcclxuICAgICAgICAgICAgY3VzdG9tUmVxdWVzdCxcclxuICAgICAgICAgICAgaW5pdEluZGV4OiBiYXNlID0+IChpbmRleE5hbWUpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbml0SW5kZXgoYmFzZSkoaW5kZXhOYW1lLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kczogeyBzZWFyY2gsIHNlYXJjaEZvckZhY2V0VmFsdWVzLCBmaW5kQW5zd2VycyB9LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgIH0pO1xyXG59XHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jdGlvbmFsL2ltbXV0YWJsZS1kYXRhXHJcbmFsZ29saWFzZWFyY2gudmVyc2lvbiA9IHZlcnNpb247XG5cbmV4cG9ydCBkZWZhdWx0IGFsZ29saWFzZWFyY2g7XG4iXSwibmFtZXMiOlsiY3JlYXRlQnJvd3NlckxvY2FsU3RvcmFnZUNhY2hlIiwib3B0aW9ucyIsIm5hbWVzcGFjZUtleSIsImtleSIsInN0b3JhZ2UiLCJnZXRTdG9yYWdlIiwidW5kZWZpbmVkIiwibG9jYWxTdG9yYWdlIiwid2luZG93IiwiZ2V0TmFtZXNwYWNlIiwiSlNPTiIsInBhcnNlIiwiZ2V0SXRlbSIsInNldE5hbWVzcGFjZSIsIm5hbWVzcGFjZSIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJyZW1vdmVPdXRkYXRlZENhY2hlSXRlbXMiLCJ0aW1lVG9MaXZlIiwiZmlsdGVyZWROYW1lc3BhY2VXaXRob3V0T2xkRm9ybWF0dGVkQ2FjaGVJdGVtcyIsIk9iamVjdCIsImZyb21FbnRyaWVzIiwiZW50cmllcyIsImZpbHRlciIsImNhY2hlSXRlbSIsInRpbWVzdGFtcCIsImZpbHRlcmVkTmFtZXNwYWNlV2l0aG91dEV4cGlyZWRJdGVtcyIsImN1cnJlbnRUaW1lc3RhbXAiLCJEYXRlIiwiZ2V0VGltZSIsImlzRXhwaXJlZCIsImdldCIsImRlZmF1bHRWYWx1ZSIsImV2ZW50cyIsIm1pc3MiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJrZXlBc1N0cmluZyIsInZhbHVlIiwiYWxsIiwiZXhpc3RzIiwic2V0IiwiZGVsZXRlIiwiY2xlYXIiLCJyZW1vdmVJdGVtIiwiY3JlYXRlRmFsbGJhY2thYmxlQ2FjaGUiLCJjYWNoZXMiLCJjdXJyZW50Iiwic2hpZnQiLCJjcmVhdGVOdWxsQ2FjaGUiLCJjYXRjaCIsIl9rZXkiLCJyZXN1bHQiLCJjcmVhdGVJbk1lbW9yeUNhY2hlIiwic2VyaWFsaXphYmxlIiwiY2FjaGUiLCJwcm9taXNlIiwiY3JlYXRlQXV0aCIsImF1dGhNb2RlIiwiYXBwSWQiLCJhcGlLZXkiLCJjcmVkZW50aWFscyIsImhlYWRlcnMiLCJBdXRoTW9kZSIsIldpdGhpbkhlYWRlcnMiLCJxdWVyeVBhcmFtZXRlcnMiLCJXaXRoaW5RdWVyeVBhcmFtZXRlcnMiLCJzaHVmZmxlIiwiYXJyYXkiLCJjIiwibGVuZ3RoIiwiYiIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsImEiLCJhZGRNZXRob2RzIiwiYmFzZSIsIm1ldGhvZHMiLCJrZXlzIiwiZm9yRWFjaCIsImVuY29kZSIsImZvcm1hdCIsImFyZ3MiLCJpIiwicmVwbGFjZSIsImVuY29kZVVSSUNvbXBvbmVudCIsInZlcnNpb24iLCJjcmVhdGVNYXBwZWRSZXF1ZXN0T3B0aW9ucyIsInJlcXVlc3RPcHRpb25zIiwidGltZW91dCIsImRhdGEiLCJpbmRleE9mIiwiY2FjaGVhYmxlIiwiQ2FsbEVudW0iLCJSZWFkIiwiV3JpdGUiLCJBbnkiLCJIb3N0U3RhdHVzRW51bSIsIlVwIiwiRG93biIsIlRpbWVvdXRlZCIsIkVYUElSQVRJT05fREVMQVkiLCJjcmVhdGVTdGF0ZWZ1bEhvc3QiLCJob3N0Iiwic3RhdHVzIiwibGFzdFVwZGF0ZSIsIm5vdyIsImlzU3RhdGVmdWxIb3N0VXAiLCJpc1N0YXRlZnVsSG9zdFRpbWVvdXRlZCIsImNyZWF0ZVN0YXRlbGVzc0hvc3QiLCJwcm90b2NvbCIsInVybCIsImFjY2VwdCIsIk1ldGhvZEVudW0iLCJEZWxldGUiLCJHZXQiLCJQb3N0IiwiUHV0IiwiY3JlYXRlUmV0cnlhYmxlT3B0aW9ucyIsImhvc3RzQ2FjaGUiLCJzdGF0ZWxlc3NIb3N0cyIsIm1hcCIsInN0YXRlbGVzc0hvc3QiLCJzdGF0ZWZ1bEhvc3RzIiwiaG9zdHNVcCIsImhvc3RzVGltZW91dGVkIiwiaG9zdHNBdmFpbGFibGUiLCJzdGF0ZWxlc3NIb3N0c0F2YWlsYWJsZSIsImdldFRpbWVvdXQiLCJ0aW1lb3V0c0NvdW50IiwiYmFzZVRpbWVvdXQiLCJ0aW1lb3V0TXVsdGlwbGllciIsImlzTmV0d29ya0Vycm9yIiwiaXNUaW1lZE91dCIsImlzUmV0cnlhYmxlIiwicmVzcG9uc2UiLCJpc1N1Y2Nlc3MiLCJyZXRyeURlY2lzaW9uIiwib3V0Y29tZXMiLCJvblJldHJ5Iiwib25TdWNjZXNzIiwib25GYWlsIiwicmV0cnlhYmxlUmVxdWVzdCIsInRyYW5zcG9ydGVyIiwicmVxdWVzdCIsInN0YWNrVHJhY2UiLCJzZXJpYWxpemVEYXRhIiwic2VyaWFsaXplSGVhZGVycyIsIm1ldGhvZCIsImRhdGFRdWVyeVBhcmFtZXRlcnMiLCJ1c2VyQWdlbnQiLCJyZXRyeSIsImhvc3RzIiwicG9wIiwiY3JlYXRlUmV0cnlFcnJvciIsInN0YWNrVHJhY2VXaXRob3V0Q3JlZGVudGlhbHMiLCJwYXlsb2FkIiwic2VyaWFsaXplVXJsIiwicGF0aCIsImNvbm5lY3RUaW1lb3V0IiwidGltZW91dHMiLCJjb25uZWN0IiwicmVzcG9uc2VUaW1lb3V0IiwicHVzaFRvU3RhY2tUcmFjZSIsInN0YWNrRnJhbWUiLCJ0cmllc0xlZnQiLCJwdXNoIiwiZGVjaXNpb25zIiwiZGVzZXJpYWxpemVTdWNjZXNzIiwibG9nZ2VyIiwiaW5mbyIsInN0YWNrRnJhbWVXaXRob3V0Q3JlZGVudGlhbHMiLCJkZXNlcmlhbGl6ZUZhaWx1cmUiLCJyZXF1ZXN0ZXIiLCJzZW5kIiwicmV2ZXJzZSIsImNyZWF0ZVRyYW5zcG9ydGVyIiwicmVxdWVzdHNDYWNoZSIsInJlc3BvbnNlc0NhY2hlIiwicmVhZCIsIm1hcHBlZFJlcXVlc3RPcHRpb25zIiwiY3JlYXRlUmV0cnlhYmxlUmVxdWVzdCIsImVyciIsInJlamVjdCIsIl8iLCJ3cml0ZSIsImNyZWF0ZVVzZXJBZ2VudCIsImFkZCIsImFkZGVkVXNlckFnZW50Iiwic2VnbWVudCIsImNvbnRlbnQiLCJlIiwiY3JlYXRlRGVzZXJpYWxpemF0aW9uRXJyb3IiLCJtZXNzYWdlIiwiY3JlYXRlQXBpRXJyb3IiLCJxdWVyeVBhcmFtZXRlcnNBc1N0cmluZyIsInNlcmlhbGl6ZVF1ZXJ5UGFyYW1ldGVycyIsImNoYXJBdCIsInN1YnN0ciIsInBhcmFtZXRlcnMiLCJpc09iamVjdE9yQXJyYXkiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJqb2luIiwiQXJyYXkiLCJpc0FycmF5Iiwic2VyaWFsaXplZEhlYWRlcnMiLCJoZWFkZXIiLCJ0b0xvd2VyQ2FzZSIsIm1vZGlmaWVkSGVhZGVycyIsInRyYW5zcG9ydGVyU3RhY2tUcmFjZSIsIm5hbWUiLCJjcmVhdGVTZWFyY2hDbGllbnQiLCJhdXRoIiwiY29uY2F0IiwiYWRkQWxnb2xpYUFnZW50IiwiY2xlYXJDYWNoZSIsImN1c3RvbVJlcXVlc3QiLCJpbml0SW5kZXgiLCJpbmRleE5hbWUiLCJzZWFyY2hJbmRleCIsIm11bHRpcGxlUXVlcmllcyIsInF1ZXJpZXMiLCJyZXF1ZXN0cyIsInF1ZXJ5IiwicGFyYW1zIiwibXVsdGlwbGVTZWFyY2hGb3JGYWNldFZhbHVlcyIsImZhY2V0TmFtZSIsImZhY2V0UXVlcnkiLCJzZWFyY2hGb3JGYWNldFZhbHVlcyIsImZpbmRBbnN3ZXJzIiwicXVlcnlMYW5ndWFnZXMiLCJzZWFyY2giLCJMb2dMZXZlbEVudW0iLCJEZWJ1ZyIsIkluZm8iLCJFcnJvciIsImNyZWF0ZUNvbnNvbGVMb2dnZXIiLCJsb2dMZXZlbCIsImRlYnVnIiwiY29uc29sZSIsImVycm9yIiwiY3JlYXRlQnJvd3NlclhoclJlcXVlc3RlciIsImJhc2VSZXF1ZXN0ZXIiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJzZXRSZXF1ZXN0SGVhZGVyIiwiY3JlYXRlVGltZW91dCIsInNldFRpbWVvdXQiLCJhYm9ydCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlYWR5U3RhdGUiLCJPUEVORUQiLCJjbGVhclRpbWVvdXQiLCJvbmVycm9yIiwicmVzcG9uc2VUZXh0Iiwib25sb2FkIiwiYWxnb2xpYXNlYXJjaCIsImNvbW1vbk9wdGlvbnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/algoliasearch/dist/algoliasearch-lite.esm.browser.js\n");

/***/ })

};
;