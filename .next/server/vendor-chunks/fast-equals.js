"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fast-equals";
exports.ids = ["vendor-chunks/fast-equals"];
exports.modules = {

/***/ "(ssr)/./node_modules/fast-equals/dist/fast-equals.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/fast-equals/dist/fast-equals.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   circularDeepEqual: () => (/* binding */ circularDeepEqual),\n/* harmony export */   circularShallowEqual: () => (/* binding */ circularShallowEqual),\n/* harmony export */   createCustomEqual: () => (/* binding */ createComparator),\n/* harmony export */   deepEqual: () => (/* binding */ deepEqual),\n/* harmony export */   sameValueZeroEqual: () => (/* binding */ sameValueZeroEqual),\n/* harmony export */   shallowEqual: () => (/* binding */ shallowEqual)\n/* harmony export */ });\nvar HAS_WEAKSET_SUPPORT = typeof WeakSet === \"function\";\nvar keys = Object.keys;\n/**\r\n * are the values passed strictly equal or both NaN\r\n *\r\n * @param a the value to compare against\r\n * @param b the value to test\r\n * @returns are the values equal by the SameValueZero principle\r\n */ function sameValueZeroEqual(a, b) {\n    return a === b || a !== a && b !== b;\n}\n/**\r\n * is the value a plain object\r\n *\r\n * @param value the value to test\r\n * @returns is the value a plain object\r\n */ function isPlainObject(value) {\n    return value.constructor === Object || value.constructor == null;\n}\n/**\r\n * is the value promise-like (meaning it is thenable)\r\n *\r\n * @param value the value to test\r\n * @returns is the value promise-like\r\n */ function isPromiseLike(value) {\n    return !!value && typeof value.then === \"function\";\n}\n/**\r\n * is the value passed a react element\r\n *\r\n * @param value the value to test\r\n * @returns is the value a react element\r\n */ function isReactElement(value) {\n    return !!(value && value.$$typeof);\n}\n/**\r\n * in cases where WeakSet is not supported, creates a new custom\r\n * object that mimics the necessary API aspects for cache purposes\r\n *\r\n * @returns the new cache object\r\n */ function getNewCacheFallback() {\n    var values = [];\n    return {\n        add: function(value) {\n            values.push(value);\n        },\n        has: function(value) {\n            return values.indexOf(value) !== -1;\n        }\n    };\n}\n/**\r\n * get a new cache object to prevent circular references\r\n *\r\n * @returns the new cache object\r\n */ var getNewCache = function(canUseWeakMap) {\n    if (canUseWeakMap) {\n        return function _getNewCache() {\n            return new WeakSet();\n        };\n    }\n    return getNewCacheFallback;\n}(HAS_WEAKSET_SUPPORT);\n/**\r\n * create a custom isEqual handler specific to circular objects\r\n *\r\n * @param [isEqual] the isEqual comparator to use instead of isDeepEqual\r\n * @returns the method to create the `isEqual` function\r\n */ function createCircularEqualCreator(isEqual) {\n    return function createCircularEqual(comparator) {\n        var _comparator = isEqual || comparator;\n        return function circularEqual(a, b, cache) {\n            if (cache === void 0) {\n                cache = getNewCache();\n            }\n            var isCacheableA = !!a && typeof a === \"object\";\n            var isCacheableB = !!b && typeof b === \"object\";\n            if (isCacheableA || isCacheableB) {\n                var hasA = isCacheableA && cache.has(a);\n                var hasB = isCacheableB && cache.has(b);\n                if (hasA || hasB) {\n                    return hasA && hasB;\n                }\n                if (isCacheableA) {\n                    cache.add(a);\n                }\n                if (isCacheableB) {\n                    cache.add(b);\n                }\n            }\n            return _comparator(a, b, cache);\n        };\n    };\n}\n/**\r\n * are the arrays equal in value\r\n *\r\n * @param a the array to test\r\n * @param b the array to test against\r\n * @param isEqual the comparator to determine equality\r\n * @param meta the meta object to pass through\r\n * @returns are the arrays equal\r\n */ function areArraysEqual(a, b, isEqual, meta) {\n    var index = a.length;\n    if (b.length !== index) {\n        return false;\n    }\n    while(index-- > 0){\n        if (!isEqual(a[index], b[index], meta)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\r\n * are the maps equal in value\r\n *\r\n * @param a the map to test\r\n * @param b the map to test against\r\n * @param isEqual the comparator to determine equality\r\n * @param meta the meta map to pass through\r\n * @returns are the maps equal\r\n */ function areMapsEqual(a, b, isEqual, meta) {\n    var isValueEqual = a.size === b.size;\n    if (isValueEqual && a.size) {\n        var matchedIndices_1 = {};\n        a.forEach(function(aValue, aKey) {\n            if (isValueEqual) {\n                var hasMatch_1 = false;\n                var matchIndex_1 = 0;\n                b.forEach(function(bValue, bKey) {\n                    if (!hasMatch_1 && !matchedIndices_1[matchIndex_1]) {\n                        hasMatch_1 = isEqual(aKey, bKey, meta) && isEqual(aValue, bValue, meta);\n                        if (hasMatch_1) {\n                            matchedIndices_1[matchIndex_1] = true;\n                        }\n                    }\n                    matchIndex_1++;\n                });\n                isValueEqual = hasMatch_1;\n            }\n        });\n    }\n    return isValueEqual;\n}\nvar OWNER = \"_owner\";\nvar hasOwnProperty = Function.prototype.bind.call(Function.prototype.call, Object.prototype.hasOwnProperty);\n/**\r\n * are the objects equal in value\r\n *\r\n * @param a the object to test\r\n * @param b the object to test against\r\n * @param isEqual the comparator to determine equality\r\n * @param meta the meta object to pass through\r\n * @returns are the objects equal\r\n */ function areObjectsEqual(a, b, isEqual, meta) {\n    var keysA = keys(a);\n    var index = keysA.length;\n    if (keys(b).length !== index) {\n        return false;\n    }\n    if (index) {\n        var key = void 0;\n        while(index-- > 0){\n            key = keysA[index];\n            if (key === OWNER) {\n                var reactElementA = isReactElement(a);\n                var reactElementB = isReactElement(b);\n                if ((reactElementA || reactElementB) && reactElementA !== reactElementB) {\n                    return false;\n                }\n            }\n            if (!hasOwnProperty(b, key) || !isEqual(a[key], b[key], meta)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n/**\r\n * are the regExps equal in value\r\n *\r\n * @param a the regExp to test\r\n * @param b the regExp to test agains\r\n * @returns are the regExps equal\r\n */ function areRegExpsEqual(a, b) {\n    return a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.unicode === b.unicode && a.sticky === b.sticky && a.lastIndex === b.lastIndex;\n}\n/**\r\n * are the sets equal in value\r\n *\r\n * @param a the set to test\r\n * @param b the set to test against\r\n * @param isEqual the comparator to determine equality\r\n * @param meta the meta set to pass through\r\n * @returns are the sets equal\r\n */ function areSetsEqual(a, b, isEqual, meta) {\n    var isValueEqual = a.size === b.size;\n    if (isValueEqual && a.size) {\n        var matchedIndices_2 = {};\n        a.forEach(function(aValue) {\n            if (isValueEqual) {\n                var hasMatch_2 = false;\n                var matchIndex_2 = 0;\n                b.forEach(function(bValue) {\n                    if (!hasMatch_2 && !matchedIndices_2[matchIndex_2]) {\n                        hasMatch_2 = isEqual(aValue, bValue, meta);\n                        if (hasMatch_2) {\n                            matchedIndices_2[matchIndex_2] = true;\n                        }\n                    }\n                    matchIndex_2++;\n                });\n                isValueEqual = hasMatch_2;\n            }\n        });\n    }\n    return isValueEqual;\n}\nvar HAS_MAP_SUPPORT = typeof Map === \"function\";\nvar HAS_SET_SUPPORT = typeof Set === \"function\";\nfunction createComparator(createIsEqual) {\n    var isEqual = /* eslint-disable no-use-before-define */ typeof createIsEqual === \"function\" ? createIsEqual(comparator) : comparator;\n    /* eslint-enable */ /**\r\n     * compare the value of the two objects and return true if they are equivalent in values\r\n     *\r\n     * @param a the value to test against\r\n     * @param b the value to test\r\n     * @param [meta] an optional meta object that is passed through to all equality test calls\r\n     * @returns are a and b equivalent in value\r\n     */ function comparator(a, b, meta) {\n        if (a === b) {\n            return true;\n        }\n        if (a && b && typeof a === \"object\" && typeof b === \"object\") {\n            if (isPlainObject(a) && isPlainObject(b)) {\n                return areObjectsEqual(a, b, isEqual, meta);\n            }\n            var aShape = Array.isArray(a);\n            var bShape = Array.isArray(b);\n            if (aShape || bShape) {\n                return aShape === bShape && areArraysEqual(a, b, isEqual, meta);\n            }\n            aShape = a instanceof Date;\n            bShape = b instanceof Date;\n            if (aShape || bShape) {\n                return aShape === bShape && sameValueZeroEqual(a.getTime(), b.getTime());\n            }\n            aShape = a instanceof RegExp;\n            bShape = b instanceof RegExp;\n            if (aShape || bShape) {\n                return aShape === bShape && areRegExpsEqual(a, b);\n            }\n            if (isPromiseLike(a) || isPromiseLike(b)) {\n                return a === b;\n            }\n            if (HAS_MAP_SUPPORT) {\n                aShape = a instanceof Map;\n                bShape = b instanceof Map;\n                if (aShape || bShape) {\n                    return aShape === bShape && areMapsEqual(a, b, isEqual, meta);\n                }\n            }\n            if (HAS_SET_SUPPORT) {\n                aShape = a instanceof Set;\n                bShape = b instanceof Set;\n                if (aShape || bShape) {\n                    return aShape === bShape && areSetsEqual(a, b, isEqual, meta);\n                }\n            }\n            return areObjectsEqual(a, b, isEqual, meta);\n        }\n        return a !== a && b !== b;\n    }\n    return comparator;\n}\nvar deepEqual = createComparator();\nvar shallowEqual = createComparator(function() {\n    return sameValueZeroEqual;\n});\nvar circularDeepEqual = createComparator(createCircularEqualCreator());\nvar circularShallowEqual = createComparator(createCircularEqualCreator(sameValueZeroEqual));\n //# sourceMappingURL=fast-equals.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFzdC1lcXVhbHMvZGlzdC9mYXN0LWVxdWFscy5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsSUFBSUEsc0JBQXNCLE9BQU9DLFlBQVk7QUFDN0MsSUFBSUMsT0FBT0MsT0FBT0QsSUFBSTtBQUN0Qjs7Ozs7O0NBTUMsR0FDRCxTQUFTRSxtQkFBbUJDLENBQUMsRUFBRUMsQ0FBQztJQUM1QixPQUFPRCxNQUFNQyxLQUFNRCxNQUFNQSxLQUFLQyxNQUFNQTtBQUN4QztBQUNBOzs7OztDQUtDLEdBQ0QsU0FBU0MsY0FBY0MsS0FBSztJQUN4QixPQUFPQSxNQUFNQyxXQUFXLEtBQUtOLFVBQVVLLE1BQU1DLFdBQVcsSUFBSTtBQUNoRTtBQUNBOzs7OztDQUtDLEdBQ0QsU0FBU0MsY0FBY0YsS0FBSztJQUN4QixPQUFPLENBQUMsQ0FBQ0EsU0FBUyxPQUFPQSxNQUFNRyxJQUFJLEtBQUs7QUFDNUM7QUFDQTs7Ozs7Q0FLQyxHQUNELFNBQVNDLGVBQWVKLEtBQUs7SUFDekIsT0FBTyxDQUFDLENBQUVBLENBQUFBLFNBQVNBLE1BQU1LLFFBQVE7QUFDckM7QUFDQTs7Ozs7Q0FLQyxHQUNELFNBQVNDO0lBQ0wsSUFBSUMsU0FBUyxFQUFFO0lBQ2YsT0FBTztRQUNIQyxLQUFLLFNBQVVSLEtBQUs7WUFDaEJPLE9BQU9FLElBQUksQ0FBQ1Q7UUFDaEI7UUFDQVUsS0FBSyxTQUFVVixLQUFLO1lBQ2hCLE9BQU9PLE9BQU9JLE9BQU8sQ0FBQ1gsV0FBVyxDQUFDO1FBQ3RDO0lBQ0o7QUFDSjtBQUNBOzs7O0NBSUMsR0FDRCxJQUFJWSxjQUFjLFNBQVdDLGFBQWE7SUFDdEMsSUFBSUEsZUFBZTtRQUNmLE9BQU8sU0FBU0M7WUFDWixPQUFPLElBQUlyQjtRQUNmO0lBQ0o7SUFDQSxPQUFPYTtBQUNYLEVBQUdkO0FBQ0g7Ozs7O0NBS0MsR0FDRCxTQUFTdUIsMkJBQTJCQyxPQUFPO0lBQ3ZDLE9BQU8sU0FBU0Msb0JBQW9CQyxV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bUJDLEVBQUU4RSxPQUFPLElBQUk3RSxFQUFFNkUsT0FBTztZQUMxRTtZQUNBTCxTQUFTekUsYUFBYStFO1lBQ3RCSCxTQUFTM0UsYUFBYThFO1lBQ3RCLElBQUlOLFVBQVVHLFFBQVE7Z0JBQ2xCLE9BQU9ILFdBQVdHLFVBQVVyQixnQkFBZ0J2RCxHQUFHQztZQUNuRDtZQUNBLElBQUlJLGNBQWNMLE1BQU1LLGNBQWNKLElBQUk7Z0JBQ3RDLE9BQU9ELE1BQU1DO1lBQ2pCO1lBQ0EsSUFBSWtFLGlCQUFpQjtnQkFDakJNLFNBQVN6RSxhQUFhb0U7Z0JBQ3RCUSxTQUFTM0UsYUFBYW1FO2dCQUN0QixJQUFJSyxVQUFVRyxRQUFRO29CQUNsQixPQUFPSCxXQUFXRyxVQUFVM0MsYUFBYWpDLEdBQUdDLEdBQUdrQixTQUFTVztnQkFDNUQ7WUFDSjtZQUNBLElBQUl1QyxpQkFBaUI7Z0JBQ2pCSSxTQUFTekUsYUFBYXNFO2dCQUN0Qk0sU0FBUzNFLGFBQWFxRTtnQkFDdEIsSUFBSUcsVUFBVUcsUUFBUTtvQkFDbEIsT0FBT0gsV0FBV0csVUFBVWIsYUFBYS9ELEdBQUdDLEdBQUdrQixTQUFTVztnQkFDNUQ7WUFDSjtZQUNBLE9BQU9vQixnQkFBZ0JsRCxHQUFHQyxHQUFHa0IsU0FBU1c7UUFDMUM7UUFDQSxPQUFPOUIsTUFBTUEsS0FBS0MsTUFBTUE7SUFDNUI7SUFDQSxPQUFPb0I7QUFDWDtBQUVBLElBQUkyRCxZQUFZVDtBQUNoQixJQUFJVSxlQUFlVixpQkFBaUI7SUFBYyxPQUFPeEU7QUFBb0I7QUFDN0UsSUFBSW1GLG9CQUFvQlgsaUJBQWlCckQ7QUFDekMsSUFBSWlFLHVCQUF1QlosaUJBQWlCckQsMkJBQTJCbkI7QUFFZ0UsQ0FDdkksMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGFpbHdpbmQtbmV4dGpzLXN0YXJ0ZXItYmxvZy8uL25vZGVfbW9kdWxlcy9mYXN0LWVxdWFscy9kaXN0L2Zhc3QtZXF1YWxzLmVzbS5qcz83MjVjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBIQVNfV0VBS1NFVF9TVVBQT1JUID0gdHlwZW9mIFdlYWtTZXQgPT09ICdmdW5jdGlvbic7XHJcbnZhciBrZXlzID0gT2JqZWN0LmtleXM7XHJcbi8qKlxyXG4gKiBhcmUgdGhlIHZhbHVlcyBwYXNzZWQgc3RyaWN0bHkgZXF1YWwgb3IgYm90aCBOYU5cclxuICpcclxuICogQHBhcmFtIGEgdGhlIHZhbHVlIHRvIGNvbXBhcmUgYWdhaW5zdFxyXG4gKiBAcGFyYW0gYiB0aGUgdmFsdWUgdG8gdGVzdFxyXG4gKiBAcmV0dXJucyBhcmUgdGhlIHZhbHVlcyBlcXVhbCBieSB0aGUgU2FtZVZhbHVlWmVybyBwcmluY2lwbGVcclxuICovXHJcbmZ1bmN0aW9uIHNhbWVWYWx1ZVplcm9FcXVhbChhLCBiKSB7XHJcbiAgICByZXR1cm4gYSA9PT0gYiB8fCAoYSAhPT0gYSAmJiBiICE9PSBiKTtcclxufVxyXG4vKipcclxuICogaXMgdGhlIHZhbHVlIGEgcGxhaW4gb2JqZWN0XHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSB0aGUgdmFsdWUgdG8gdGVzdFxyXG4gKiBAcmV0dXJucyBpcyB0aGUgdmFsdWUgYSBwbGFpbiBvYmplY3RcclxuICovXHJcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0IHx8IHZhbHVlLmNvbnN0cnVjdG9yID09IG51bGw7XHJcbn1cclxuLyoqXHJcbiAqIGlzIHRoZSB2YWx1ZSBwcm9taXNlLWxpa2UgKG1lYW5pbmcgaXQgaXMgdGhlbmFibGUpXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSB0aGUgdmFsdWUgdG8gdGVzdFxyXG4gKiBAcmV0dXJucyBpcyB0aGUgdmFsdWUgcHJvbWlzZS1saWtlXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1Byb21pc2VMaWtlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJztcclxufVxyXG4vKipcclxuICogaXMgdGhlIHZhbHVlIHBhc3NlZCBhIHJlYWN0IGVsZW1lbnRcclxuICpcclxuICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSB0byB0ZXN0XHJcbiAqIEByZXR1cm5zIGlzIHRoZSB2YWx1ZSBhIHJlYWN0IGVsZW1lbnRcclxuICovXHJcbmZ1bmN0aW9uIGlzUmVhY3RFbGVtZW50KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuJCR0eXBlb2YpO1xyXG59XHJcbi8qKlxyXG4gKiBpbiBjYXNlcyB3aGVyZSBXZWFrU2V0IGlzIG5vdCBzdXBwb3J0ZWQsIGNyZWF0ZXMgYSBuZXcgY3VzdG9tXHJcbiAqIG9iamVjdCB0aGF0IG1pbWljcyB0aGUgbmVjZXNzYXJ5IEFQSSBhc3BlY3RzIGZvciBjYWNoZSBwdXJwb3Nlc1xyXG4gKlxyXG4gKiBAcmV0dXJucyB0aGUgbmV3IGNhY2hlIG9iamVjdFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TmV3Q2FjaGVGYWxsYmFjaygpIHtcclxuICAgIHZhciB2YWx1ZXMgPSBbXTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYWRkOiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGFzOiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlcy5pbmRleE9mKHZhbHVlKSAhPT0gLTE7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIGdldCBhIG5ldyBjYWNoZSBvYmplY3QgdG8gcHJldmVudCBjaXJjdWxhciByZWZlcmVuY2VzXHJcbiAqXHJcbiAqIEByZXR1cm5zIHRoZSBuZXcgY2FjaGUgb2JqZWN0XHJcbiAqL1xyXG52YXIgZ2V0TmV3Q2FjaGUgPSAoZnVuY3Rpb24gKGNhblVzZVdlYWtNYXApIHtcclxuICAgIGlmIChjYW5Vc2VXZWFrTWFwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIF9nZXROZXdDYWNoZSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWFrU2V0KCk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiBnZXROZXdDYWNoZUZhbGxiYWNrO1xyXG59KShIQVNfV0VBS1NFVF9TVVBQT1JUKTtcclxuLyoqXHJcbiAqIGNyZWF0ZSBhIGN1c3RvbSBpc0VxdWFsIGhhbmRsZXIgc3BlY2lmaWMgdG8gY2lyY3VsYXIgb2JqZWN0c1xyXG4gKlxyXG4gKiBAcGFyYW0gW2lzRXF1YWxdIHRoZSBpc0VxdWFsIGNvbXBhcmF0b3IgdG8gdXNlIGluc3RlYWQgb2YgaXNEZWVwRXF1YWxcclxuICogQHJldHVybnMgdGhlIG1ldGhvZCB0byBjcmVhdGUgdGhlIGBpc0VxdWFsYCBmdW5jdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlQ2lyY3VsYXJFcXVhbENyZWF0b3IoaXNFcXVhbCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUNpcmN1bGFyRXF1YWwoY29tcGFyYXRvcikge1xyXG4gICAgICAgIHZhciBfY29tcGFyYXRvciA9IGlzRXF1YWwgfHwgY29tcGFyYXRvcjtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY2lyY3VsYXJFcXVhbChhLCBiLCBjYWNoZSkge1xyXG4gICAgICAgICAgICBpZiAoY2FjaGUgPT09IHZvaWQgMCkgeyBjYWNoZSA9IGdldE5ld0NhY2hlKCk7IH1cclxuICAgICAgICAgICAgdmFyIGlzQ2FjaGVhYmxlQSA9ICEhYSAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCc7XHJcbiAgICAgICAgICAgIHZhciBpc0NhY2hlYWJsZUIgPSAhIWIgJiYgdHlwZW9mIGIgPT09ICdvYmplY3QnO1xyXG4gICAgICAgICAgICBpZiAoaXNDYWNoZWFibGVBIHx8IGlzQ2FjaGVhYmxlQikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGhhc0EgPSBpc0NhY2hlYWJsZUEgJiYgY2FjaGUuaGFzKGEpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGhhc0IgPSBpc0NhY2hlYWJsZUIgJiYgY2FjaGUuaGFzKGIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhc0EgfHwgaGFzQikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYXNBICYmIGhhc0I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNDYWNoZWFibGVBKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuYWRkKGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzQ2FjaGVhYmxlQikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLmFkZChiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gX2NvbXBhcmF0b3IoYSwgYiwgY2FjaGUpO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBhcmUgdGhlIGFycmF5cyBlcXVhbCBpbiB2YWx1ZVxyXG4gKlxyXG4gKiBAcGFyYW0gYSB0aGUgYXJyYXkgdG8gdGVzdFxyXG4gKiBAcGFyYW0gYiB0aGUgYXJyYXkgdG8gdGVzdCBhZ2FpbnN0XHJcbiAqIEBwYXJhbSBpc0VxdWFsIHRoZSBjb21wYXJhdG9yIHRvIGRldGVybWluZSBlcXVhbGl0eVxyXG4gKiBAcGFyYW0gbWV0YSB0aGUgbWV0YSBvYmplY3QgdG8gcGFzcyB0aHJvdWdoXHJcbiAqIEByZXR1cm5zIGFyZSB0aGUgYXJyYXlzIGVxdWFsXHJcbiAqL1xyXG5mdW5jdGlvbiBhcmVBcnJheXNFcXVhbChhLCBiLCBpc0VxdWFsLCBtZXRhKSB7XHJcbiAgICB2YXIgaW5kZXggPSBhLmxlbmd0aDtcclxuICAgIGlmIChiLmxlbmd0aCAhPT0gaW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB3aGlsZSAoaW5kZXgtLSA+IDApIHtcclxuICAgICAgICBpZiAoIWlzRXF1YWwoYVtpbmRleF0sIGJbaW5kZXhdLCBtZXRhKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiAqIGFyZSB0aGUgbWFwcyBlcXVhbCBpbiB2YWx1ZVxyXG4gKlxyXG4gKiBAcGFyYW0gYSB0aGUgbWFwIHRvIHRlc3RcclxuICogQHBhcmFtIGIgdGhlIG1hcCB0byB0ZXN0IGFnYWluc3RcclxuICogQHBhcmFtIGlzRXF1YWwgdGhlIGNvbXBhcmF0b3IgdG8gZGV0ZXJtaW5lIGVxdWFsaXR5XHJcbiAqIEBwYXJhbSBtZXRhIHRoZSBtZXRhIG1hcCB0byBwYXNzIHRocm91Z2hcclxuICogQHJldHVybnMgYXJlIHRoZSBtYXBzIGVxdWFsXHJcbiAqL1xyXG5mdW5jdGlvbiBhcmVNYXBzRXF1YWwoYSwgYiwgaXNFcXVhbCwgbWV0YSkge1xyXG4gICAgdmFyIGlzVmFsdWVFcXVhbCA9IGEuc2l6ZSA9PT0gYi5zaXplO1xyXG4gICAgaWYgKGlzVmFsdWVFcXVhbCAmJiBhLnNpemUpIHtcclxuICAgICAgICB2YXIgbWF0Y2hlZEluZGljZXNfMSA9IHt9O1xyXG4gICAgICAgIGEuZm9yRWFjaChmdW5jdGlvbiAoYVZhbHVlLCBhS2V5KSB7XHJcbiAgICAgICAgICAgIGlmIChpc1ZhbHVlRXF1YWwpIHtcclxuICAgICAgICAgICAgICAgIHZhciBoYXNNYXRjaF8xID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2hJbmRleF8xID0gMDtcclxuICAgICAgICAgICAgICAgIGIuZm9yRWFjaChmdW5jdGlvbiAoYlZhbHVlLCBiS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNNYXRjaF8xICYmICFtYXRjaGVkSW5kaWNlc18xW21hdGNoSW5kZXhfMV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzTWF0Y2hfMSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0VxdWFsKGFLZXksIGJLZXksIG1ldGEpICYmIGlzRXF1YWwoYVZhbHVlLCBiVmFsdWUsIG1ldGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzTWF0Y2hfMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZEluZGljZXNfMVttYXRjaEluZGV4XzFdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBtYXRjaEluZGV4XzErKztcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaXNWYWx1ZUVxdWFsID0gaGFzTWF0Y2hfMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGlzVmFsdWVFcXVhbDtcclxufVxyXG52YXIgT1dORVIgPSAnX293bmVyJztcclxudmFyIGhhc093blByb3BlcnR5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChGdW5jdGlvbi5wcm90b3R5cGUuY2FsbCwgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XHJcbi8qKlxyXG4gKiBhcmUgdGhlIG9iamVjdHMgZXF1YWwgaW4gdmFsdWVcclxuICpcclxuICogQHBhcmFtIGEgdGhlIG9iamVjdCB0byB0ZXN0XHJcbiAqIEBwYXJhbSBiIHRoZSBvYmplY3QgdG8gdGVzdCBhZ2FpbnN0XHJcbiAqIEBwYXJhbSBpc0VxdWFsIHRoZSBjb21wYXJhdG9yIHRvIGRldGVybWluZSBlcXVhbGl0eVxyXG4gKiBAcGFyYW0gbWV0YSB0aGUgbWV0YSBvYmplY3QgdG8gcGFzcyB0aHJvdWdoXHJcbiAqIEByZXR1cm5zIGFyZSB0aGUgb2JqZWN0cyBlcXVhbFxyXG4gKi9cclxuZnVuY3Rpb24gYXJlT2JqZWN0c0VxdWFsKGEsIGIsIGlzRXF1YWwsIG1ldGEpIHtcclxuICAgIHZhciBrZXlzQSA9IGtleXMoYSk7XHJcbiAgICB2YXIgaW5kZXggPSBrZXlzQS5sZW5ndGg7XHJcbiAgICBpZiAoa2V5cyhiKS5sZW5ndGggIT09IGluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKGluZGV4KSB7XHJcbiAgICAgICAgdmFyIGtleSA9IHZvaWQgMDtcclxuICAgICAgICB3aGlsZSAoaW5kZXgtLSA+IDApIHtcclxuICAgICAgICAgICAga2V5ID0ga2V5c0FbaW5kZXhdO1xyXG4gICAgICAgICAgICBpZiAoa2V5ID09PSBPV05FUikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlYWN0RWxlbWVudEEgPSBpc1JlYWN0RWxlbWVudChhKTtcclxuICAgICAgICAgICAgICAgIHZhciByZWFjdEVsZW1lbnRCID0gaXNSZWFjdEVsZW1lbnQoYik7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHJlYWN0RWxlbWVudEEgfHwgcmVhY3RFbGVtZW50QikgJiZcclxuICAgICAgICAgICAgICAgICAgICByZWFjdEVsZW1lbnRBICE9PSByZWFjdEVsZW1lbnRCKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcGVydHkoYiwga2V5KSB8fCAhaXNFcXVhbChhW2tleV0sIGJba2V5XSwgbWV0YSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbi8qKlxyXG4gKiBhcmUgdGhlIHJlZ0V4cHMgZXF1YWwgaW4gdmFsdWVcclxuICpcclxuICogQHBhcmFtIGEgdGhlIHJlZ0V4cCB0byB0ZXN0XHJcbiAqIEBwYXJhbSBiIHRoZSByZWdFeHAgdG8gdGVzdCBhZ2FpbnNcclxuICogQHJldHVybnMgYXJlIHRoZSByZWdFeHBzIGVxdWFsXHJcbiAqL1xyXG5mdW5jdGlvbiBhcmVSZWdFeHBzRXF1YWwoYSwgYikge1xyXG4gICAgcmV0dXJuIChhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiZcclxuICAgICAgICBhLmdsb2JhbCA9PT0gYi5nbG9iYWwgJiZcclxuICAgICAgICBhLmlnbm9yZUNhc2UgPT09IGIuaWdub3JlQ2FzZSAmJlxyXG4gICAgICAgIGEubXVsdGlsaW5lID09PSBiLm11bHRpbGluZSAmJlxyXG4gICAgICAgIGEudW5pY29kZSA9PT0gYi51bmljb2RlICYmXHJcbiAgICAgICAgYS5zdGlja3kgPT09IGIuc3RpY2t5ICYmXHJcbiAgICAgICAgYS5sYXN0SW5kZXggPT09IGIubGFzdEluZGV4KTtcclxufVxyXG4vKipcclxuICogYXJlIHRoZSBzZXRzIGVxdWFsIGluIHZhbHVlXHJcbiAqXHJcbiAqIEBwYXJhbSBhIHRoZSBzZXQgdG8gdGVzdFxyXG4gKiBAcGFyYW0gYiB0aGUgc2V0IHRvIHRlc3QgYWdhaW5zdFxyXG4gKiBAcGFyYW0gaXNFcXVhbCB0aGUgY29tcGFyYXRvciB0byBkZXRlcm1pbmUgZXF1YWxpdHlcclxuICogQHBhcmFtIG1ldGEgdGhlIG1ldGEgc2V0IHRvIHBhc3MgdGhyb3VnaFxyXG4gKiBAcmV0dXJucyBhcmUgdGhlIHNldHMgZXF1YWxcclxuICovXHJcbmZ1bmN0aW9uIGFyZVNldHNFcXVhbChhLCBiLCBpc0VxdWFsLCBtZXRhKSB7XHJcbiAgICB2YXIgaXNWYWx1ZUVxdWFsID0gYS5zaXplID09PSBiLnNpemU7XHJcbiAgICBpZiAoaXNWYWx1ZUVxdWFsICYmIGEuc2l6ZSkge1xyXG4gICAgICAgIHZhciBtYXRjaGVkSW5kaWNlc18yID0ge307XHJcbiAgICAgICAgYS5mb3JFYWNoKGZ1bmN0aW9uIChhVmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKGlzVmFsdWVFcXVhbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGhhc01hdGNoXzIgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHZhciBtYXRjaEluZGV4XzIgPSAwO1xyXG4gICAgICAgICAgICAgICAgYi5mb3JFYWNoKGZ1bmN0aW9uIChiVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc01hdGNoXzIgJiYgIW1hdGNoZWRJbmRpY2VzXzJbbWF0Y2hJbmRleF8yXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNNYXRjaF8yID0gaXNFcXVhbChhVmFsdWUsIGJWYWx1ZSwgbWV0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNNYXRjaF8yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkSW5kaWNlc18yW21hdGNoSW5kZXhfMl0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoSW5kZXhfMisrO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpc1ZhbHVlRXF1YWwgPSBoYXNNYXRjaF8yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXNWYWx1ZUVxdWFsO1xyXG59XG5cbnZhciBIQVNfTUFQX1NVUFBPUlQgPSB0eXBlb2YgTWFwID09PSAnZnVuY3Rpb24nO1xyXG52YXIgSEFTX1NFVF9TVVBQT1JUID0gdHlwZW9mIFNldCA9PT0gJ2Z1bmN0aW9uJztcclxuZnVuY3Rpb24gY3JlYXRlQ29tcGFyYXRvcihjcmVhdGVJc0VxdWFsKSB7XHJcbiAgICB2YXIgaXNFcXVhbCA9IFxyXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdXNlLWJlZm9yZS1kZWZpbmUgKi9cclxuICAgIHR5cGVvZiBjcmVhdGVJc0VxdWFsID09PSAnZnVuY3Rpb24nXHJcbiAgICAgICAgPyBjcmVhdGVJc0VxdWFsKGNvbXBhcmF0b3IpXHJcbiAgICAgICAgOiBjb21wYXJhdG9yO1xyXG4gICAgLyogZXNsaW50LWVuYWJsZSAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBjb21wYXJlIHRoZSB2YWx1ZSBvZiB0aGUgdHdvIG9iamVjdHMgYW5kIHJldHVybiB0cnVlIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQgaW4gdmFsdWVzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGEgdGhlIHZhbHVlIHRvIHRlc3QgYWdhaW5zdFxyXG4gICAgICogQHBhcmFtIGIgdGhlIHZhbHVlIHRvIHRlc3RcclxuICAgICAqIEBwYXJhbSBbbWV0YV0gYW4gb3B0aW9uYWwgbWV0YSBvYmplY3QgdGhhdCBpcyBwYXNzZWQgdGhyb3VnaCB0byBhbGwgZXF1YWxpdHkgdGVzdCBjYWxsc1xyXG4gICAgICogQHJldHVybnMgYXJlIGEgYW5kIGIgZXF1aXZhbGVudCBpbiB2YWx1ZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjb21wYXJhdG9yKGEsIGIsIG1ldGEpIHtcclxuICAgICAgICBpZiAoYSA9PT0gYikge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1BsYWluT2JqZWN0KGEpICYmIGlzUGxhaW5PYmplY3QoYikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhcmVPYmplY3RzRXF1YWwoYSwgYiwgaXNFcXVhbCwgbWV0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGFTaGFwZSA9IEFycmF5LmlzQXJyYXkoYSk7XHJcbiAgICAgICAgICAgIHZhciBiU2hhcGUgPSBBcnJheS5pc0FycmF5KGIpO1xyXG4gICAgICAgICAgICBpZiAoYVNoYXBlIHx8IGJTaGFwZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFTaGFwZSA9PT0gYlNoYXBlICYmIGFyZUFycmF5c0VxdWFsKGEsIGIsIGlzRXF1YWwsIG1ldGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFTaGFwZSA9IGEgaW5zdGFuY2VvZiBEYXRlO1xyXG4gICAgICAgICAgICBiU2hhcGUgPSBiIGluc3RhbmNlb2YgRGF0ZTtcclxuICAgICAgICAgICAgaWYgKGFTaGFwZSB8fCBiU2hhcGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoYVNoYXBlID09PSBiU2hhcGUgJiYgc2FtZVZhbHVlWmVyb0VxdWFsKGEuZ2V0VGltZSgpLCBiLmdldFRpbWUoKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFTaGFwZSA9IGEgaW5zdGFuY2VvZiBSZWdFeHA7XHJcbiAgICAgICAgICAgIGJTaGFwZSA9IGIgaW5zdGFuY2VvZiBSZWdFeHA7XHJcbiAgICAgICAgICAgIGlmIChhU2hhcGUgfHwgYlNoYXBlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYVNoYXBlID09PSBiU2hhcGUgJiYgYXJlUmVnRXhwc0VxdWFsKGEsIGIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc1Byb21pc2VMaWtlKGEpIHx8IGlzUHJvbWlzZUxpa2UoYikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhID09PSBiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChIQVNfTUFQX1NVUFBPUlQpIHtcclxuICAgICAgICAgICAgICAgIGFTaGFwZSA9IGEgaW5zdGFuY2VvZiBNYXA7XHJcbiAgICAgICAgICAgICAgICBiU2hhcGUgPSBiIGluc3RhbmNlb2YgTWFwO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFTaGFwZSB8fCBiU2hhcGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYVNoYXBlID09PSBiU2hhcGUgJiYgYXJlTWFwc0VxdWFsKGEsIGIsIGlzRXF1YWwsIG1ldGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChIQVNfU0VUX1NVUFBPUlQpIHtcclxuICAgICAgICAgICAgICAgIGFTaGFwZSA9IGEgaW5zdGFuY2VvZiBTZXQ7XHJcbiAgICAgICAgICAgICAgICBiU2hhcGUgPSBiIGluc3RhbmNlb2YgU2V0O1xyXG4gICAgICAgICAgICAgICAgaWYgKGFTaGFwZSB8fCBiU2hhcGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYVNoYXBlID09PSBiU2hhcGUgJiYgYXJlU2V0c0VxdWFsKGEsIGIsIGlzRXF1YWwsIG1ldGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhcmVPYmplY3RzRXF1YWwoYSwgYiwgaXNFcXVhbCwgbWV0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhICE9PSBhICYmIGIgIT09IGI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29tcGFyYXRvcjtcclxufVxuXG52YXIgZGVlcEVxdWFsID0gY3JlYXRlQ29tcGFyYXRvcigpO1xyXG52YXIgc2hhbGxvd0VxdWFsID0gY3JlYXRlQ29tcGFyYXRvcihmdW5jdGlvbiAoKSB7IHJldHVybiBzYW1lVmFsdWVaZXJvRXF1YWw7IH0pO1xyXG52YXIgY2lyY3VsYXJEZWVwRXF1YWwgPSBjcmVhdGVDb21wYXJhdG9yKGNyZWF0ZUNpcmN1bGFyRXF1YWxDcmVhdG9yKCkpO1xyXG52YXIgY2lyY3VsYXJTaGFsbG93RXF1YWwgPSBjcmVhdGVDb21wYXJhdG9yKGNyZWF0ZUNpcmN1bGFyRXF1YWxDcmVhdG9yKHNhbWVWYWx1ZVplcm9FcXVhbCkpO1xuXG5leHBvcnQgeyBjaXJjdWxhckRlZXBFcXVhbCwgY2lyY3VsYXJTaGFsbG93RXF1YWwsIGNyZWF0ZUNvbXBhcmF0b3IgYXMgY3JlYXRlQ3VzdG9tRXF1YWwsIGRlZXBFcXVhbCwgc2FtZVZhbHVlWmVyb0VxdWFsLCBzaGFsbG93RXF1YWwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZhc3QtZXF1YWxzLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJIQVNfV0VBS1NFVF9TVVBQT1JUIiwiV2Vha1NldCIsImtleXMiLCJPYmplY3QiLCJzYW1lVmFsdWVaZXJvRXF1YWwiLCJhIiwiYiIsImlzUGxhaW5PYmplY3QiLCJ2YWx1ZSIsImNvbnN0cnVjdG9yIiwiaXNQcm9taXNlTGlrZSIsInRoZW4iLCJpc1JlYWN0RWxlbWVudCIsIiQkdHlwZW9mIiwiZ2V0TmV3Q2FjaGVGYWxsYmFjayIsInZhbHVlcyIsImFkZCIsInB1c2giLCJoYXMiLCJpbmRleE9mIiwiZ2V0TmV3Q2FjaGUiLCJjYW5Vc2VXZWFrTWFwIiwiX2dldE5ld0NhY2hlIiwiY3JlYXRlQ2lyY3VsYXJFcXVhbENyZWF0b3IiLCJpc0VxdWFsIiwiY3JlYXRlQ2lyY3VsYXJFcXVhbCIsImNvbXBhcmF0b3IiLCJfY29tcGFyYXRvciIsImNpcmN1bGFyRXF1YWwiLCJjYWNoZSIsImlzQ2FjaGVhYmxlQSIsImlzQ2FjaGVhYmxlQiIsImhhc0EiLCJoYXNCIiwiYXJlQXJyYXlzRXF1YWwiLCJtZXRhIiwiaW5kZXgiLCJsZW5ndGgiLCJhcmVNYXBzRXF1YWwiLCJpc1ZhbHVlRXF1YWwiLCJzaXplIiwibWF0Y2hlZEluZGljZXNfMSIsImZvckVhY2giLCJhVmFsdWUiLCJhS2V5IiwiaGFzTWF0Y2hfMSIsIm1hdGNoSW5kZXhfMSIsImJWYWx1ZSIsImJLZXkiLCJPV05FUiIsImhhc093blByb3BlcnR5IiwiRnVuY3Rpb24iLCJwcm90b3R5cGUiLCJiaW5kIiwiY2FsbCIsImFyZU9iamVjdHNFcXVhbCIsImtleXNBIiwia2V5IiwicmVhY3RFbGVtZW50QSIsInJlYWN0RWxlbWVudEIiLCJhcmVSZWdFeHBzRXF1YWwiLCJzb3VyY2UiLCJnbG9iYWwiLCJpZ25vcmVDYXNlIiwibXVsdGlsaW5lIiwidW5pY29kZSIsInN0aWNreSIsImxhc3RJbmRleCIsImFyZVNldHNFcXVhbCIsIm1hdGNoZWRJbmRpY2VzXzIiLCJoYXNNYXRjaF8yIiwibWF0Y2hJbmRleF8yIiwiSEFTX01BUF9TVVBQT1JUIiwiTWFwIiwiSEFTX1NFVF9TVVBQT1JUIiwiU2V0IiwiY3JlYXRlQ29tcGFyYXRvciIsImNyZWF0ZUlzRXF1YWwiLCJhU2hhcGUiLCJBcnJheSIsImlzQXJyYXkiLCJiU2hhcGUiLCJEYXRlIiwiZ2V0VGltZSIsIlJlZ0V4cCIsImRlZXBFcXVhbCIsInNoYWxsb3dFcXVhbCIsImNpcmN1bGFyRGVlcEVxdWFsIiwiY2lyY3VsYXJTaGFsbG93RXF1YWwiLCJjcmVhdGVDdXN0b21FcXVhbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fast-equals/dist/fast-equals.esm.js\n");

/***/ })

};
;